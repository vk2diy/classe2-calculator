#!/usr/bin/python
import argparse
import bisect
import decimal
import itertools
import json
import commentjson
import math
import random
import re
import sys
import time
from bisect import bisect_left
from collections import OrderedDict
from datetime import datetime, timezone
from decimal import Decimal, getcontext
from functools import lru_cache
from itertools import combinations_with_replacement
from math import isclose


debug_enabled = False

def convert_h_to_nh(value):
    return value * 1e9

def convert_mh_to_nh(value):
    return value * 1e6

def convert_h_to_uh(inductance_h):
    return inductance_h * 1e6

def convert_uh_to_h(inductance_uh):
    return inductance_uh * 1e-6

def convert_nh_to_uh(inductance_nh):
    return inductance_nh * 1e-3

def convert_uh_to_nh(inductance_uh):
    return inductance_uh * 1e3

def convert_ma_to_a(value_ma):
    return value_ma / 1000

# Inductance conversions
def convert_h_to_mh(value_h):
    return value_h * 1000

def convert_h_to_uh(value_h):
    return value_h * 1e6

def convert_h_to_nh(value_h):
    return value_h * 1e9

def convert_mh_to_h(value_mh):
    return value_mh / 1000

def convert_uh_to_h(value_uh):
    return value_uh / 1e6

def convert_nh_to_h(value_nh):
    return value_nh / 1e9

# Frequency conversions
def convert_hz_to_khz(value_hz):
    return value_hz / 1000

def convert_hz_to_mhz(value_hz):
    return value_hz / 1e6

def convert_hz_to_ghz(value_hz):
    return value_hz / 1e9

def convert_khz_to_hz(value_khz):
    return value_khz * 1000

def convert_mhz_to_hz(value_mhz):
    return value_mhz * 1e6

def convert_ghz_to_hz(value_ghz):
    return value_ghz * 1e9

# Resistance conversions
def convert_ohms_to_kohms(value_ohms):
    return value_ohms / 1000

def convert_ohms_to_mohms(value_ohms):
    return value_ohms / 1e6

def convert_kohms_to_ohms(value_kohms):
    return value_kohms * 1000

def convert_mohms_to_ohms(value_mohms):
    return value_mohms * 1e6

# Current conversions
def convert_a_to_ma(value_a):
    return value_a * 1000

def convert_a_to_ua(value_a):
    return value_a * 1e6

def convert_ma_to_a(value_ma):
    return value_ma / 1000

def convert_ua_to_a(value_ua):
    return value_ua / 1e6

# Voltage conversions
def convert_v_to_mv(value_v):
    return value_v * 1000

def convert_v_to_uv(value_v):
    return value_v * 1e6

def convert_mv_to_v(value_mv):
    return value_mv / 1000

def convert_uv_to_v(value_uv):
    return value_uv / 1e6

# Capacitance conversions
def convert_f_to_mf(value_f):
    return value_f * 1000

def convert_f_to_uf(value_f):
    return value_f * 1e6

def convert_f_to_nf(value_f):
    return value_f * 1e9

def convert_f_to_pf(value_f):
    return value_f * 1e12

def convert_mf_to_f(value_mf):
    return value_mf / 1000

def convert_uf_to_f(value_uf):
    return value_uf / 1e6

def convert_nf_to_f(value_nf):
    return value_nf / 1e9

def convert_pf_to_f(value_pf):
    return value_pf / 1e12

# Power conversions
def convert_w_to_mw(value_w):
    return value_w * 1000

def convert_w_to_kw(value_w):
    return value_w / 1000

def convert_mw_to_w(value_mw):
    return value_mw / 1000

def convert_kw_to_w(value_kw):
    return value_kw * 1000

# Updated formatting functions
def format_power_value(value_w):
    if value_w >= 1000:
        return f"{convert_w_to_kw(value_w):.2f}kW"
    elif value_w >= 1:
        return f"{value_w:.2f}W"
    else:
        return f"{convert_w_to_mw(value_w):.2f}mW"

def format_voltage_value(value_v):
    if value_v >= 1000:
        return f"{value_v / 1000:.2f}kV"
    elif value_v >= 1:
        return f"{value_v:.2f}V"
    elif value_v >= 0.001:
        return f"{convert_v_to_mv(value_v):.2f}mV"
    else:
        return f"{convert_v_to_uv(value_v):.2f}µV"

def format_capacitance_value(value_f):
    if value_f >= 1:
        return f"{value_f:.2f}F"
    elif value_f >= 1e-3:
        return f"{convert_f_to_mf(value_f):.2f}mF"
    elif value_f >= 1e-6:
        return f"{convert_f_to_uf(value_f):.2f}µF"
    elif value_f >= 1e-9:
        return f"{convert_f_to_nf(value_f):.2f}nF"
    else:
        return f"{convert_f_to_pf(value_f):.2f}pF"

class ClassETopologyGenerator:

    def __init__(self):
        self.pi = math.pi

    def class_e_topology_generate_inverse(self, power, voltage, center_freq, bandwidth, mosfet_data, q_factor, L1=None):
        omega = 2 * math.pi * center_freq
        L1_min = 0.1 * voltage**2 / (omega * power)
        if L1 is None:
            L1 = L1_min
            L1_status = "calculated"
        else:
            L1_status = "user-specified"
            L1 = parse_inductance(L1)
            if L1 < L1_min:
                print(f"Warning: User-specified L1 ({L1:.2e}H) is less than the calculated minimum ({L1_min:.2e}H)")

        if L1 < L1_min:
            raise ValueError(f"L1 is too small. Minimum value: {L1_min:.3e} H")
        R = 0.5768 * voltage**2 / power
        C2 = 0.1836 / (omega * R)
        C1 = 1 / (omega**2 * L1) - C2
        L2 = R / (omega * 1.1525)
        if q_factor is None:
            q_factor = math.sqrt(L1 / C1) / R
        duty_cycle = 0.5
        efficiency = 0.9  # Theoretical maximum for Class E

        return { 'L1': L1, 'C1': C1, 'R': R, 'C2': C2, 'L2': L2, 'Q': q_factor, 'duty_cycle': duty_cycle, 'efficiency': efficiency, "L1_status": L1_status, "L1_min": L1_min }

    def class_e_topology_generate_infinite(self, output_power_watts, pa_voltage_volts, center_frequency_hz, bandwidth_hz, mosfet_data, Q, L1=None):
        w0 = 2 * math.pi * center_frequency_hz

        Vo = 0  # Assume 0V for MOSFETs
        Coss = mosfet_data['coss_pf'] * 1e-12

        R = 0.576801 * ((pa_voltage_volts - Vo)**2 / output_power_watts) * (1.0000086 - (0.414396 / Q) - (0.577501 / (Q**2)) + (0.205967 / (Q**3)))

        L1_min = ((math.pi**2 + 4) * R) / w0

        if L1 is None:
            L1 = ((math.pi**2 + 4) * R) / w0  # Minimum value for L1
            L1_status = "calculated"
        else:
            L1_status = "user-specified"
            L1 = parse_inductance(L1)
            if L1 < L1_min:
                print(f"Warning: User-specified L1 ({L1:.2e}H) is less than the calculated minimum ({L1_min:.2e}H)")

        # C1 calculation uses Raab's 2001 formula
        C1 = (1 / (34.2219 * center_frequency_hz * R)) * (0.99866 + (0.91424 / Q) - (1.03175 / (Q**2))) + (0.6 / ((2 * math.pi * center_frequency_hz)**2 * L1))
        L2 = (Q * R) / w0
        C2 = (1 / (w0 * R)) * (1 / (Q - 0.104823)) * (1.00121 + 1.01468 / (Q - 1.7879))

        return { "L1": L1, "L2": L2, "C1": C1, "C2": C2, "R": R, "L1_status": L1_status, "L1_min": L1_min }

    def class_e_topology_generate_finite(self, output_power_watts, pa_voltage_volts, center_frequency_hz, bandwidth_hz, mosfet_data, Q, L1=None):
        w0 = 2 * self.pi * center_frequency_hz

        Vo = 0  # Assume 0V for MOSFETs
        Coss = mosfet_data['coss_pf'] * 1e-12

        R = 0.576801 * ((pa_voltage_volts - Vo)**2 / output_power_watts) * (1.0000086 - (0.414396 / Q) - (0.577501 / (Q**2)) + (0.205967 / (Q**3)))
        C1 = (1 / (34.2219 * center_frequency_hz * R)) * (0.99866 + (0.91424 / Q) - (1.03175 / (Q**2))) - Coss
        L2 = (1.15 * R) / w0
        C2 = (1 / (w0 * R)) * (1 / (Q - 0.104823)) * (1.00121 + 1.01468 / (Q - 1.7879))

        if L1 is None:
            L1 = (0.1836 * R) / w0
            L1_status = "calculated"
        else:
            L1_optimal = (0.1836 * R) / w0
            L1_status = "user-specified"
            if abs(L1 - L1_optimal) / L1_optimal > 0.1:  # If L1 differs by more than 10% from optimal
                print(f"Warning: User-specified L1 ({L1:.2e}H) differs significantly from the calculated optimal value ({L1_optimal:.2e}H)")

        return { "L1": L1, "L2": L2, "C1": C1, "C2": C2, "R": R, "L1_status": L1_status }

    def calculate_operating_parameters(self, pa_voltage_volts, center_frequency_hz, Q, R):
        peak_vds = pa_voltage_volts * 3.56 / 0.8
        bandwidth = center_frequency_hz / Q
        # Estimate harmonics (simplified model)
        # These are rough estimates and may not be accurate for all designs
        second_harmonic = -20 * math.log10(Q)  # dB below fundamental
        third_harmonic = -30 * math.log10(Q)   # dB below fundamental
        # Calculate drain efficiency (simplified estimate)
        # This is a theoretical maximum, actual efficiency will be lower
        drain_efficiency = 100 * (math.pi**2 / 4 + 1) / (math.pi**2 / 2 + 2)  # in percentage
        # Calculate maximum drain current (simplified estimate)
        max_drain_current = (2 * math.pi * pa_voltage_volts) / (math.pi**2 * R)

        return { "peak_vds": peak_vds, "bandwidth": bandwidth, "second_harmonic": second_harmonic, "third_harmonic": third_harmonic, "drain_efficiency": drain_efficiency, "max_drain_current": max_drain_current }

from itertools import combinations_with_replacement

def get_utc_date():
    # Get the current UTC time
    utc_now = datetime.now(timezone.utc)

    # Format the date string
    # This format closely mimics the output of the 'date' command
    return utc_now.strftime("%a %b %d %H:%M:%S UTC %Y")

def convert_mhz_to_hz(frequency_mhz):
    return frequency_mhz * 1e6

def convert_f_to_pf(value_f):
    return value_f * 1e12

def convert_pf_to_f(value_pf):
    return value_pf * 1e-12

def convert_h_to_uh(value_h):
    return value_h * 1e6

def convert_uh_to_h(value_uh):
    return value_uh * 1e-6

def debug_print(*args, **kwargs):
    if debug_enabled:
        print("DEBUG: ", *args, file=sys.stderr, **kwargs)

def load_components(filename='components.json'):
    with open(filename, 'r') as f:
        return json.load(f)

COMPONENTS = load_components()

def format_frequency_range(min_frequency_mhz, max_frequency_mhz):
    if min_frequency_mhz >= 1000:
        return f"{format_number_for_clarity(min_frequency_mhz/1000,True)}-{format_number_for_clarity(max_frequency_mhz/1000,True)}GHz"
    elif max_frequency_mhz >= 1000:
        return f"{format_number_for_clarity(min_frequency_mhz,True)}MHz-{format_number_for_clarity(max_frequency_mhz/1000,True)}GHz"
    else:
        return f"{format_number_for_clarity(min_frequency_mhz,True)}-{format_number_for_clarity(max_frequency_mhz,True)}MHz"

def get_max_frequency(bands):
    return max(FREQUENCY_BANDS[band]['end'] for band in bands)

def format_band_with_range(band):
    band_data = FREQUENCY_BANDS[band]
    formatted_range = format_frequency_range(band_data['start'], band_data['end'])
    return f"{band} ({formatted_range})"

def convert_to_uh(value_str):
    if value_str.endswith('nH'):
        return round(float(value_str[:-2]) / 1000, 3)  # Convert nH to µH and round to 3 decimal places
    elif value_str.endswith('µH'):
        return round(float(value_str[:-2]), 3)  # Round to 3 decimal places
    else:
        return round(float(value_str), 3)  # Assume it's already in µH and round

def load_inductor_data():
    debug_print("Loading inductor data...")
    with open('inductors.json', 'r') as f:
        return commentjson.load(f)

def preprocess_inductors(inductors_data):
    preprocessed_data = []
    error_count = 0
    total_count = 0

    for manufacturer, models in inductors_data.items():
        for model, data in models.items():
            total_count += 1
            try:
                inductance_uh = convert_to_uh(data['inductance'])

                # Check for valid inductance
                if inductance_uh <= 0:
                    raise ValueError(f"Invalid inductance value: {data['inductance']}")

                # Check for valid DCR (DC Resistance)
                dcr = data.get('dcr', None)
                if dcr is not None:
                    if not isinstance(dcr, (int, float)) or dcr < 0:
                        raise ValueError(f"Invalid DCR value: {dcr}")

                # Check for valid IDC (DC Current)
                idc = data.get('idc', None)
                if idc is not None:
                    if not isinstance(idc, (int, float)) or idc <= 0 or idc == float('inf'):
                        raise ValueError(f"Invalid IDC value: {idc}")

                # Check for valid SRF (Self-Resonant Frequency)
                srf = data.get('srf', None)
                if srf is not None:
                    if not isinstance(srf, (int, float)) or srf <= 0:
                        raise ValueError(f"Invalid SRF value: {srf}")

                preprocessed_data.append((model, inductance_uh))

            except KeyError as e:
                print(f"Error: Missing required data for {manufacturer} {model}: {str(e)}")
                error_count += 1
            except ValueError as e:
                print(f"Error: Invalid data for {manufacturer} {model}: {str(e)}")
                error_count += 1
            except Exception as e:
                print(f"Unexpected error processing {manufacturer} {model}: {str(e)}")
                error_count += 1

    debug_print(f"preprocess_inductors() complete - {len(preprocessed_data)} valid entries, {error_count} errors out of {total_count} total entries.")
    return preprocessed_data

def prune_inductors(inductors_h, frequency_bands, bands):
    max_freq = max(band['end'] for band_name, band in frequency_bands.items() if band_name in bands)
    debug_print(f"prune_inductors() for bands {bands} means maximum frequency {max_freq}MHz")
    pruned = [ind for ind in inductors_h if estimate_srf_optimistic(ind) > max_freq * 3]
    debug_print(f"prune_inductors() reduced available inductors from {len(inductors_h)} to {len(pruned)}")
    return pruned

INDUCTORS = load_inductor_data()
PREPROCESSED_INDUCTORS = preprocess_inductors(INDUCTORS)

def load_inductor_srf_range_data():
    data = INDUCTORS
    inductor_srf_ranges = {}
    for manufacturer, inductors in data.items():
        for part_number, inductor in inductors.items():
            if isinstance(inductor, dict) and 'inductance' in inductor and 'srf_mhz' in inductor:
                inductance_str = inductor['inductance']
                debug_print(f"Inductance was {inductance_str}")
                if inductance_str.endswith('nH'):
                    inductance = convert_nh_to_uh(float(inductance_str[:-2])) # Convert nH to µH
                elif inductance_str.endswith('µH'):
                    inductance = float(inductance_str[:-2])
                else:
                    print(f"WARNING: Unknown unit or unitless inductance string value '{inductance_str}'!")
                    inductance = float(inductance_str)
                debug_print(f"Inductance is now {inductance}")
                srf = float(inductor['srf_mhz'])
                if inductance not in inductor_srf_ranges:
                    inductor_srf_ranges[inductance] = [srf, srf]  # [min, max]
                else:
                    inductor_srf_ranges[inductance][0] = min(inductor_srf_ranges[inductance][0], srf)
                    inductor_srf_ranges[inductance][1] = max(inductor_srf_ranges[inductance][1], srf)

    debug_print("Loaded SRF ranges:")
    for inductance, srf_range in sorted(inductor_srf_ranges.items()):
        debug_print(f"  {inductance}µH: {srf_range[0]}-{srf_range[1]}MHz")

    return inductor_srf_ranges

INDUCTOR_SRF_RANGES = load_inductor_srf_range_data()

def get_srf_range(inductance_h):
    inductance_uh = convert_h_to_uh(inductance_h)
    keys = sorted(INDUCTOR_SRF_RANGES.keys())
    idx = bisect.bisect_left(keys, inductance_uh)

    if idx == 0:
        return INDUCTOR_SRF_RANGES[keys[0]]
    elif idx == len(keys):
        return INDUCTOR_SRF_RANGES[keys[-1]]
    else:
        lower_key = keys[idx-1]
        upper_key = keys[idx]
        lower_range = INDUCTOR_SRF_RANGES[lower_key]
        upper_range = INDUCTOR_SRF_RANGES[upper_key]
        # Interpolate
        factor = (inductance_uh - lower_key) / (upper_key - lower_key)
        min_srf = lower_range[0] + (upper_range[0] - lower_range[0]) * factor
        max_srf = lower_range[1] + (upper_range[1] - lower_range[1]) * factor
        return (min_srf, max_srf)

def estimate_srf_optimistic(inductance_h):
    return get_srf_range(inductance_h)[1]

def estimate_srf_pessimistic(inductance_h):
    return get_srf_range(inductance_h)[0]

def calculate_inductor_configuration_srf_safety_factor(inductance):
    if inductance < 1e-8:  # Less than 10nH
        return 2.5
    elif inductance < 1e-7:  # Less than 100nH
        return 2.0
    elif inductance < 1e-6:  # Less than 1µH
        return 1.5
    else:
        return 1.2

def parallel_combination(v1, v2):
    return (v1 * v2) / (v1 + v2)

def series_combination(*values):
    return sum(values)

def generate_inductor_configurations(target_value_h, inductors_h, frequency_bands, max_components=5, max_configurations=30, bands=None, min_current=None):
    configurations = []

    pruned_inductors = prune_inductors(inductors_h, frequency_bands, bands)
    sorted_inductors_h = sorted(set(pruned_inductors))

    precise_match = find_precise_match(target_value_h, sorted_inductors_h)
    if precise_match:
        srf = estimate_srf_optimistic(precise_match)
        idc = get_inductor_properties(precise_match)[2]
        if min_current is None or idc >= min_current * 1000:
            configurations.append(([[precise_match]], target_value_h, srf))

    for num_parts in range(2, max_components + 1):
        new_configs = generate_multi_part_configs(target_value_h, sorted_inductors_h, num_parts)
        for config in new_configs:
            if isinstance(config, (int, float)):
                config = [config]
            elif isinstance(config[0], list):
                config = [item for sublist in config for item in sublist]

            total_value = sum(config)
            try:
                srf = min(estimate_srf_optimistic(ind) for ind in config)
                dcr = sum(get_inductor_properties(ind)[1] for ind in config)
                idc = min(get_inductor_properties(ind)[2] for ind in config)

                if min_current is None or idc >= min_current * 1000:
                    configurations.append(([config], total_value, srf))
            except ValueError as e:
                print(f"Warning: Skipping configuration due to error: {e}")
                continue

    configurations.sort(key=lambda x: (
        sum(len(group) for group in x[0]),  # Total part count
        count_unique_parts(x),  # Unique part count
        -abs(x[1] - target_value_h) / target_value_h  # Negative accuracy (for descending order)
    ))

    return configurations[:max_configurations]

def find_precise_match(target_value, inductors):
    target_float = parse_inductance(target_value)
    return next((ind for ind in inductors if abs(ind - target_float) < 1e-9), None)

def generate_multi_part_configs(target_value_h, inductors_h, num_parts, tolerance=0.05):
    configs = []
    min_inductor_value = (target_value_h / num_parts) * 0.1  # 10% of average part value

    for combo in combinations_with_replacement(inductors_h, num_parts):
        if combo[0] < min_inductor_value:
            continue

        total = sum(combo)
        accuracy = 1 - abs(total - target_value_h) / target_value_h
        if accuracy >= (1 - tolerance):
            configs.append(list(combo))  # Always return a list of inductor values

        if len(configs) >= 1000:
            break
    return configs

def count_unique_parts(config):
    # Flatten the nested list structure
    flat_config = [item for sublist in config[0] for item in sublist]
    # Convert each float to a string representation to make it hashable
    return len(set(f"{x:.9f}" for x in flat_config))

def is_valid_configuration(config_h, frequency_bands, bands):
    debug_print(f"Checking validity of configuration: {config_h}")
    srf_mhz = calculate_inductor_configuration_srf(config_h)
    debug_print(f"Calculated SRF: {srf_mhz} MHz")

    max_freq = max(frequency_bands[band]['end'] for band in bands)
    debug_print(f"Maximum frequency for selected bands: {max_freq} MHz")

    if srf_mhz < max_freq * 3:
        debug_print(f"Configuration rejected: SRF {srf_mhz} MHz is less than 3 times max frequency {max_freq} MHz")
        return False

    debug_print(f"Configuration accepted: SRF {srf_mhz} MHz is at least 3 times max frequency {max_freq} MHz")
    return True

def calculate_inductor_configuration_srf(config):
    # This function needs to be implemented based on your specific requirements
    # For now, we'll use a placeholder implementation
    return min(get_inductor_properties(ind)[0] for ind in config)

def get_inductor_properties(inductance, tolerance=1e-06):
    closest_match = None
    min_difference = float('inf')
    for manufacturer, models in INDUCTORS.items():
        for model, data in models.items():
            current_inductance = parse_inductance(data['inductance'])
            difference = abs(current_inductance - inductance)
            if difference < min_difference:
                min_difference = difference
                closest_match = data

    if closest_match and min_difference <= tolerance:
        return closest_match['srf_mhz'], closest_match['dcr_ohms'], closest_match['idc_ma']
    else:
        raise ValueError(f"No matching inductor found for inductance {inductance}µH within tolerance {tolerance}")

def generate_combinations(target_values, tolerance=0.1, max_configs=3):
    def generate_for_single(target, component_type):
        configurations = []
        for value in COMPONENTS['inductors_uh' if component_type.startswith('L') else 'capacitors_pf']:
            std_value = value * (1e-6 if component_type.startswith('L') else 1e-12)
            error = abs(std_value - target) / target
            if error <= tolerance:
                configurations.append((error, (std_value,), 1, 1))
        return sorted(configurations, key=lambda x: x[0])[:max_configs]

    all_configs = [generate_for_single(target, component_type)
                   for component_type, target in target_values.items()]

    return list(itertools.product(*all_configs))[:max_configs]

def format_configuration(config, component_type):
    error, parts, esr_factor, current_factor = config
    if component_type == 'L':
        formatted_value = format_inductance_value(sum(parts) * 1e-6)
        parts_str = ' + '.join(format_inductance_value(p * 1e-6) for p in parts)
    else:  # component_type == 'C'
        formatted_value = format_capacitance_value(sum(parts) * 1e-12)
        parts_str = ' + '.join(format_capacitance_value(p * 1e-12) for p in parts)

    # Determine ESR description
    if esr_factor == 1:
        esr_desc = "ESR=standard"
    elif esr_factor < 1:
        esr_desc = "ESR=reduced"
    else:
        esr_desc = f"ESR=sum"

    # Determine current handling description
    if current_factor == 1:
        current_desc = "I=normal"
    elif current_factor == 0.5:
        current_desc = "I=half"
    elif current_factor < 1:
        current_desc = f"I=smallest"
    else:
        current_desc = f"I={current_factor:.2f}x(?)"

    return f"({error:.2f}% error) {formatted_value} ({parts_str}) [{esr_desc}] [{current_desc}]"

def evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq):
    L2_error = abs(L2 - target_L2) / target_L2
    C1_error = abs(C1 - target_C1) / target_C1
    C2_error = abs(C2 - target_C2) / target_C2
    total_error = L2_error + C1_error + C2_error
    
    L2_srf = estimate_srf(L2)
    srf_margin = L2_srf / center_freq
    
    return total_error, srf_margin

def find_closest_standard_value(target_value, standard_values):
    return min(standard_values, key=lambda x: abs(x - target_value))

def generate_matching_network_configs(matching_network, matching_network_type, standard_capacitors, standard_inductors, center_freq):
    debug_print(f"generate_matching_network_configs input:")
    debug_print(f"  matching_network = {matching_network}")
    debug_print(f"  matching_network_type = {matching_network_type}")
    debug_print(f"  standard_capacitors = {standard_capacitors[:5]}... (first 5 elements)")
    debug_print(f"  standard_inductors = {standard_inductors[:5]}... (first 5 elements)")
    debug_print(f"  center_freq = {center_freq}")

    configs = []

    component_values = dict(matching_network)

    # Precise configuration
    precise_config = {}
    for component, value in component_values.items():
        if component.startswith('C'):
            std_values = standard_capacitors
            value_converted = convert_f_to_pf(value)
        else:
            std_values = standard_inductors
            value_converted = convert_h_to_uh(value)
        debug_print(f"Converting {component}: {value} to {value_converted} {'pF' if component.startswith('C') else 'µH'}")
        combination, error, comb_type = find_best_component_combination(value_converted, std_values)
        precise_config[component] = (combination, error, comb_type)
        debug_print(f"Precise {component}: ideal={value_converted:.6f}, actual={sum(combination):.6f}, error={error:.6f}%")

    precise_config['type'] = 'precise'
    precise_config['error'] = max(v[1] for v in precise_config.values() if isinstance(v, tuple))
    debug_print(f"Precise configuration total error: {precise_config['error']:.6f}%")
    configs.append(precise_config)

    # Approximate configurations
    for component in component_values.keys():
        approx_config = {}
        for comp, val in component_values.items():
            if comp.startswith('C'):
                std_values = standard_capacitors
                val_converted = convert_f_to_pf(val)
            else:
                std_values = standard_inductors
                val_converted = convert_h_to_uh(val)

            if comp == component:
                # For the current component, find a simpler combination
                combination, error, comb_type = find_best_component_combination(val_converted, std_values, max_components=2)
            else:
                # For other components, use the closest standard value
                closest = min(std_values, key=lambda x: abs(x - val_converted))
                combination, error, comb_type = (closest,), calculate_error_percentage(val_converted, closest), 'single'

            approx_config[comp] = (combination, error, comb_type)
            debug_print(f"Approx {comp}: ideal={val_converted:.6f}, actual={sum(combination):.6f}, error={error:.6f}%")

        approx_config['type'] = f'approximate_{component}'
        approx_config['error'] = max(v[1] for v in approx_config.values() if isinstance(v, tuple))
        debug_print(f"Approximate configuration ({component}) total error: {approx_config['error']:.6f}%")
        configs.append(approx_config)

    # Sort configurations by error and return top 3
    sorted_configs = sorted(configs, key=lambda x: x['error'])[:3]
    for i, config in enumerate(sorted_configs):
        debug_print(f"Configuration {i+1} type: {config['type']}, error: {config['error']:.6f}%")
        for comp, value in config.items():
            if comp != 'type' and comp != 'error':
                if isinstance(value, tuple) and len(value) == 3:
                    combination, error, comb_type = value
                    debug_print(f"  {comp}: {combination}, error: {error:.6f}%, type: {comb_type}")
                else:
                    debug_print(f"  {comp}: {value} (unexpected format)")

    return sorted_configs

def find_next_best_standard_value(target_value, standard_values, closest_value):
    sorted_values = sorted(standard_values, key=lambda x: abs(x - target_value))
    return sorted_values[sorted_values.index(closest_value) + 1]

def find_best_component_combination(target_value, standard_values, max_components=3):
    debug_print(f"find_best_component_combination input:")
    debug_print(f"  target_value = {target_value}")
    debug_print(f"  standard_values = {standard_values[:5]}... (first 5 elements)")
    debug_print(f"  max_components = {max_components}")

    # Determine the scale of the target value
    scale = 10 ** math.floor(math.log10(target_value))
    scaled_target = target_value / scale
    scaled_standards = [v / scale for v in standard_values if v / scale <= 10 * scaled_target]

    best_combination = None
    min_error = float('inf')
    combination_type = None

    for num_components in range(1, max_components + 1):
        for combination in itertools.combinations_with_replacement(scaled_standards, num_components):
            # Try series combination
            series_sum = sum(combination)
            series_error = abs(series_sum - scaled_target) / scaled_target * 100

            # Try parallel combination
            parallel_sum = 1 / sum(1/c for c in combination)
            parallel_error = abs(parallel_sum - scaled_target) / scaled_target * 100

            if series_error < min_error:
                min_error = series_error
                best_combination = combination
                combination_type = 'series'

            if parallel_error < min_error:
                min_error = parallel_error
                best_combination = combination
                combination_type = 'parallel'

    # Scale the best combination back to the original scale
    best_combination = tuple(v * scale for v in best_combination)

    debug_print(f"find_best_component_combination output:")
    debug_print(f"  best_combination = {best_combination}")
    debug_print(f"  min_error = {min_error}%")
    debug_print(f"  combination_type = {combination_type}")
    return best_combination, min_error, combination_type

def calculate_error_percentage(ideal, actual):
    error = abs(ideal - actual) / ideal * 100
#    debug_print(f"calculate_error_percentage(ideal={ideal}, actual={actual})")
#    debug_print(f"calculate_error_percentage() returning {error}")
    return error

def rebalance_matching_network(C1, L, C2, standard_capacitors, standard_inductors):
    debug_print(f"standard_capacitors = {standard_capacitors[:5]}... (first 5 elements)")
    debug_print(f"standard_inductors = {standard_inductors[:5]}... (first 5 elements)")

def rebalance_matching_network(component_values, matching_network_type, approx_values, fixed_component, standard_capacitors, standard_inductors):
    debug_print(f"rebalance_matching_network input:")
    debug_print(f" component_values = {component_values}")
    debug_print(f" matching_network_type = {matching_network_type}")
    debug_print(f" approx_values = {approx_values}")
    debug_print(f" fixed_component = {fixed_component}")
    debug_print(f" standard_capacitors = {standard_capacitors}")
    debug_print(f" standard_inductors = {standard_inductors}")
    # Implement rebalancing logic here
    # For now, we'll just return the approx_values as is
    return approx_values

def rank_matching_network_configs(configs, ideal_components):
    for config in configs:
        errors = []
        for comp, value in config.items():
            if comp != 'type':
                ideal_value = ideal_components[comp]
                errors.append(calculate_error_percentage(ideal_value, value[0]))
        config['max_error'] = max(errors)

    return sorted(configs, key=lambda x: x['max_error'])

def find_closest(arr, target):
    pos = bisect_left(arr, target)
    if pos == 0:
        return arr[0]
    if pos == len(arr):
        return arr[-1]
    before = arr[pos - 1]
    after = arr[pos]
    if after - target < target - before:
        return after
    else:
        return before

def evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq):
    L2_error = abs(L2 - target_L2) / target_L2
    C1_error = abs(C1 - target_C1) / target_C1
    C2_error = abs(C2 - target_C2) / target_C2
    total_error = L2_error + C1_error + C2_error

    L2_srf = estimate_srf(L2)
    srf_margin = L2_srf / center_freq

    return total_error, srf_margin

def find_combinations(target, values, max_components=2, tolerance=0.05, is_inductor=False):
    combinations = []

    # Single component
    closest = find_closest(values, target)
    combinations.append((closest, 'single', f'{format_number(closest)}'))

    if max_components >= 2:
        # Parallel combinations
        for i, v1 in enumerate(values):
            for v2 in values[i:]:
                combined = parallel_combination(v1, v2)
                if abs(combined - target) / target <= tolerance:
                    v1_str = format_inductance_value(v1) if is_inductor else format_capacitance_value(v1)
                    v2_str = format_inductance_value(v2) if is_inductor else format_capacitance_value(v2)
                    combinations.append((combined, 'parallel', f'{v1_str} || {v2_str}'))

        # Series combinations
        for i, v1 in enumerate(values):
            for v2 in values[i:]:
                combined = series_combination(v1, v2)
                if abs(combined - target) / target <= tolerance:
                    v1_str = format_inductance_value(v1) if is_inductor else format_capacitance_value(v1)
                    v2_str = format_inductance_value(v2) if is_inductor else format_capacitance_value(v2)
                    combinations.append((combined, 'series', f'{v1_str} + {v2_str}'))

    combinations.sort(key=lambda x: abs(x[0] - target))
    return combinations[:5]  # Return top 5 combinations

def check_srf_margin(srf_margin):
    return srf_margin >= 3, "Good" if srf_margin >= 3 else "Concern"

def esr_multiplier(config_type, component_count):
    if config_type == 'single':
        return 1
    elif config_type == 'series':
        return component_count
    elif config_type == 'parallel':
        return 1 / component_count
    else:
        return 1  # Default case

def current_multiplier(config_type, component_count):
    if config_type == 'single':
        return 1
    elif config_type == 'series':
        return 1 / component_count
    elif config_type == 'parallel':
        return component_count
    else:
        return 1  # Default case

def find_best_configurations(target_L2, target_C1, target_C2, center_freq, num_results=3):
    L2_values = [x * 1e-6 for x in COMPONENTS['inductors_uh']]
    C_values = [x * 1e-12 for x in COMPONENTS['capacitors_pf']]

    L2_combinations = find_combinations(target_L2, L2_values, is_inductor=True)
    C1_combinations = find_combinations(target_C1, C_values, is_inductor=False)
    C2_combinations = find_combinations(target_C2, C_values, is_inductor=False)

    configurations = []
    for L2, L2_type, L2_desc in L2_combinations:
        for C1, C1_type, C1_desc in C1_combinations:
            for C2, C2_type, C2_desc in C2_combinations:
                error, srf_margin = evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq)
                component_count = sum(2 if config_type != 'single' else 1 for config_type in [L2_type, C1_type, C2_type])
                configurations.append((L2, C1, C2, L2_type, L2_desc, C1_type, C1_desc, C2_type, C2_desc, error, srf_margin, component_count))

    configurations.sort(key=lambda x: (x[9], -x[10], x[11]))  # Sort by error (ascending), SRF margin (descending), and component count (ascending)
    return configurations[:num_results]

def calculate_auto_q(band_data):
    f_lower = band_data['start'] * 1e6  # Convert to Hz
    f_upper = band_data['end'] * 1e6    # Convert to Hz
    f_center = (f_upper + f_lower) / 2
    natural_bandwidth = f_upper - f_lower
    desired_bandwidth = 1.2 * natural_bandwidth
    auto_q = f_center / desired_bandwidth
    return auto_q

def parse_frequency(value_str):
    if value_str is None:
        return None
    units = {
        'h': 1, 'mh': 1e-3, 'uh': 1e-6, 'nh': 1e-9, 'ph': 1e-12,
        'hz': 1, 'khz': 1e3, 'mhz': 1e6, 'ghz': 1e9
    }
    value, unit = re.match(r'([\d.]+)\s*([a-z]+)', value_str.lower()).groups()
    return float(value) * units[unit]

def parse_current(value_str):
    debug_print(f"parse_current() called with value_str='{value_str}'")
    value_str = value_str.lower()
    if value_str.endswith('ma'):
        return float(value_str[:-2]) / 1000
    elif value_str.endswith('m'):  # Add this case for 'mA' without the 'A'
        return float(value_str[:-1]) / 1000
    elif value_str.endswith('ua'):
        return float(value_str[:-2]) / 1000000
    elif value_str_str.endswith('a'):
        return float(value_str[:-1])
    else:
        try:
            return float(value_str)
        except ValueError:
            raise ValueError(f"Invalid current value_str: {value}")

def parse_inductance(value_str):
    getcontext().prec = 15  # Set precision to 15 significant digits

    #debug_print(f"Parsing inductance value_str: {value}")

    if isinstance(value_str, (int, float)):
        return to_float(Decimal(value_str))

    value_str = value_str.lower().replace('µ', 'u')  # Replace micro symbol with 'u'
    multipliers = {
        'ph': Decimal('1e-12'),
        'nh': Decimal('1e-9'),
        'uh': Decimal('1e-6'),
        'mh': Decimal('1e-3'),
        'h': Decimal('1')
    }

    for unit, multiplier in multipliers.items():
        if value_str.endswith(unit):
            try:
                numeric_part = value_str[:-len(unit)]
                #debug_print(f"Numeric part: {numeric_part}")
                result = to_float(Decimal(numeric_part) * multiplier)
                #debug_print(f"Parsed result: {result}")
                return result
            except decimal.InvalidOperation as e:
                debug_print(f"Error parsing {value_str}: {e}")
                raise ValueError(f"Invalid inductance value_str: {value_str}")

    try:
        result = to_float(Decimal(value_str))
        #debug_print(f"Parsed result: {result}")
        return result
    except decimal.InvalidOperation as e:
        debug_print(f"Error parsing '{value_str}': {e}")
        raise ValueError(f"Invalid inductance value: '{value_str}'")

def load_frequency_bands(filename='frequency_bands.json'):
    with open(filename, 'r') as f:
        return json.load(f)

# Get the list of available bands
FREQUENCY_BANDS = load_frequency_bands()
AVAILABLE_BANDS = list(FREQUENCY_BANDS.keys())

def calculate_center_frequency_and_bandwidth(band_data):
    center_freq = (band_data['start'] + band_data['end']) / 2
    bandwidth = band_data['end'] - band_data['start']
    return center_freq * 1e6, bandwidth * 1e6  # Convert to Hz

def format_number_for_clarity(value,preserve_decimals=False):
    # Convert the input to a string if it's not already
    value_str = str(value)

    # Use regex to separate the number and unit (if any)
    match = re.match(r'^(-?\d*\.?\d+)\s*(.*)$', value_str)

    if match:
        number, unit = match.groups()

        # Convert the number to a float for processing
        number = float(number)

        # Format the number
        if not preserve_decimals:
            if number.is_integer():
                formatted_number = f"{number:.0f}"
            elif abs(number) < 0.1:
                formatted_number = f"{number:.3f}"
            elif abs(number) < 1:
                formatted_number = f"{number:.2f}"
            elif abs(number) < 10:
                formatted_number = f"{number:.1f}"
            else:
                formatted_number = f"{number:.0f}"
        else:
            formatted_number = number

        # Remove non-significant trailing zeroes
        formatted_number = '{0:g}'.format(float(formatted_number))

        # Combine the formatted number with the unit (if any)
        #debug_print(f"format_number_for_clarity() passed '{value}' returning '{formatted_number}' (preserve_decimals={preserve_decimals})")
        return f"{formatted_number}{unit}"
    else:
        # If the input doesn't match the expected format, return it unchanged
        return value_str

def to_float(value):
    return float(value) if isinstance(value, Decimal) else value

def format_inductance_value(value_h):
    value_h=to_float(value_h)
    if value_h >= 1:
        return format_number_for_clarity(f"{value_h:.3f}H")
    elif value_h >= 1e-3:
        return format_number_for_clarity(f"{convert_h_to_mh(value_h):.3f}mH")
    elif value_h >= 1e-9:
        return format_number_for_clarity(f"{convert_h_to_uh(value_h):.3f}µH")
    else:
        return format_number_for_clarity(f"{convert_h_to_nh(value_h):.3f}nH")

def format_resistance_value(value_ohms):
    value_ohms=to_float(value_ohms)
    if value_ohms >= 1e6:
        return format_number_for_clarity(f"{convert_ohms_to_mohms(value_ohms):.3f}MΩ")
    elif value_ohms >= 1e3:
        return format_number_for_clarity(f"{convert_ohms_to_kohms(value_ohms):.3f}kΩ")
    else:
        return format_number_for_clarity(f"{value_ohms:.3f}Ω")

def format_frequency_value(value_hz):
    value_hz=to_float(value_hz)
    if value_hz >= 1e9:
        return format_number_for_clarity(f"{convert_hz_to_ghz(value_hz):.3f}GHz")
    elif value_hz >= 1e6:
        return format_number_for_clarity(f"{convert_hz_to_mhz(value_hz):.3f}MHz")
    elif value_hz >= 1e3:
        return format_number_for_clarity(f"{convert_hz_to_khz(value_hz):.3f}kHz")
    else:
        return format_number_for_clarity(f"{value_hz:.3f}Hz")

def format_current_value(value_a):
    value_a=to_float(value_a)
    if value_a >= 1:
        return format_number_for_clarity(f"{value_a:.3f}A")
    elif value_a >= 1e-3:
        return format_number_for_clarity(f"{convert_a_to_ma(value_a):.3f}mA")
    elif value_a >= 1e-6:
        return format_number_for_clarity(f"{convert_a_to_ua(value_a):.3f}µA")
    else:
        return format_number_for_clarity(f"{convert_a_to_na(valua_a):.3f}nA")

def format_capacitance_series_string(target_value, component_list):
    components = recommend_components(target_value, component_list, False)
    if components:
        combo, error, total = components[0]
        return f"{'+'.join(format_capacitance_value(c*1e-12) for c in combo)} " \
               f"(total: {format_capacitance_value(total)}≈{format_capacitance_value(target_value)}±{format_percentage(error*100)})"
    return "No suitable combination found"

def format_capacitance_parallel_string(target_value, component_list):
    components = recommend_components(target_value, component_list, False)
    if components:
        combo, error, total = components[0]
        return f"{' || '.join(format_capacitance_value(c*1e-12) for c in combo)} " \
               f"(total: {format_capacitance_value(total)}≈{format_capacitance_value(target_value)}±{format_percentage(error*100)})"
    return "No suitable combination found"

def format_percentage(value):
    return format_number_for_clarity(f"{value:.2f}%")

def format_number(value, precision=3):
    if abs(value) < 1e-9:  # Treat very small numbers as zero
        return "0"
    formatted = f"{value:.{precision}f}"
    return formatted.rstrip('0').rstrip('.')


def list_available_bands(frequency_bands):
    for band_id, band_data in frequency_bands.items():
        start_freq = format_frequency_value(band_data['start'] * 1e6)
        end_freq = format_frequency_value(band_data['end'] * 1e6)
        print(f"{band_id}:{start_freq}-{end_freq}")

def load_mosfets(filename='mosfets.json'):
    with open(filename, 'r') as f:
        return json.load(f)

MOSFETS = load_mosfets()
AVAILABLE_MOSFETS = list(MOSFETS.keys())

def list_available_mosfets(mosfets):
    print("Available MOSFETs:")
    sorted_mosfets = OrderedDict(sorted(mosfets.items()))
    for mosfet_id, mosfet_data in sorted_mosfets.items():
        mosfet_info = [
            mosfet_id,
            mosfet_data.get('lcsc', 'N/A'),
            f"{mosfet_data.get('vdss_v', 'N/A')}V",
            f"{mosfet_data.get('id_a', 'N/A')}A",
            f"{mosfet_data.get('rds_on_o', 'N/A')}Ω",
            f"{mosfet_data.get('ciss_pf', 'N/A')}pF",
            f"{mosfet_data.get('coss_pf', 'N/A')}pF",
            f"{mosfet_data.get('crss_pf', 'N/A')}pF",
            f"{mosfet_data.get('vgs_th_v', 'N/A')}V"
        ]
        print(":".join(mosfet_info))

def get_standard_value(value, component_type):
    if component_type.startswith('L'):
        standard_values = COMPONENTS['inductors_uh']
        value_uh = value * 1e6  # Convert to µH
    else:  # Capacitor
        standard_values = COMPONENTS['capacitors_pf']
        value_pf = value * 1e12  # Convert to pF

    closest = min(standard_values, key=lambda x: abs(x - (value_uh if component_type.startswith('L') else value_pf)))

    # Ensure we don't return 0 values
    if closest == 0:
        closest = min(filter(lambda x: x > 0, standard_values))

    return closest * 1e-6 if component_type.startswith('L') else closest * 1e-12  # Convert back to H or F

def calculate_output_impedance(f, C1):
    if isinstance(C1, dict):
        C1_value = C1.get('value', C1.get('C1', None))
    elif isinstance(C1, (int, float)):
        C1_value = C1
    else:
        raise ValueError(f"Unexpected type for C1: {type(C1)}")

    if C1_value is None or not isinstance(C1_value, (int, float)):
        raise ValueError(f"Invalid C1 value: {C1_value}")

    Z_out = 0.28 / (2 * math.pi * f * C1_value)
    debug_print(f"calculate_output_impedance: f={f}, C1={C1_value}, Z_out={Z_out}")
    return Z_out

def get_component_options(target, component_type, tolerance=0.1, max_options=5):
    options = []
    for value in COMPONENTS['inductors_uh' if component_type == 'L' else 'capacitors_pf']:
        std_value = value * (1e-6 if component_type == 'L' else 1e-12)
        error = abs(std_value - target) / target
        if error <= tolerance:
            options.append((error, std_value))
    return sorted(options, key=lambda x: x[0])[:max_options]

def calculate_lpf(f_cutoff, standard_capacitors_pf, standard_inductors_uh, order=5):
    debug_print(f"calculate_lpf() called with f_cutoff={f_cutoff}, standard_capacitors_pf={standard_capacitors_pf}, standard_inductors_uh={standard_inductors_uh}, order={order}")
    def calculate_butterworth_coefficients(n):
        coefficients = {
            1: [2.0],
            2: [1.4142, 1.4142],
            3: [1.0, 2.0, 1.0],
            4: [0.7654, 1.8478, 1.8478, 0.7654],
            5: [0.6180, 1.6180, 2.0, 1.6180, 0.6180],
            6: [0.5176, 1.4142, 1.9318, 1.9318, 1.4142, 0.5176],
            7: [0.4450, 1.2470, 1.8019, 2.0000, 1.8019, 1.2470, 0.4450]
        }
        if n in coefficients:
            return coefficients[n]
        else:
            raise ValueError("Unsupported filter order. Only orders 1-7 are supported.")

    w_c = 2 * math.pi * f_cutoff
    g_values = calculate_butterworth_coefficients(order)

    component_values = []
    for i, g in enumerate(g_values, 1):
        if i % 2 == 1:  # Odd index: capacitor
            value = g / (w_c * 50) * 1e12  # Convert to pF
        else:  # Even index: inductor
            value = g * 50 / w_c * 1e6  # Convert to µH
        component_values.append(value)

    precise_config = {}
    approx_config = {}
    for i, value in enumerate(component_values, 1):
        key = f"{'C' if i % 2 else 'L'}{(i + 1) // 2}"
        std_values = standard_capacitors_pf if i % 2 else standard_inductors_uh

        # Precise configuration
        combination, error, comb_type = find_best_component_combination(value, std_values)
        precise_config[key] = (combination, error, comb_type)

        # Approximate configuration (lower component count)
        approx_combination, approx_error, approx_comb_type = find_best_component_combination(value, std_values, max_components=1)
        approx_config[key] = (approx_combination, approx_error, approx_comb_type)

    precise_config['error'] = max(v[1] for v in precise_config.values())
    approx_config['error'] = max(v[1] for v in approx_config.values())

    return precise_config, approx_config

def ordinal(n):
    if 11 <= (n % 100) <= 13:
        suffix = 'th'
    else:
        suffix = {1: 'st', 2: 'nd', 3: 'rd'}.get(n % 10, 'th')
    return f"{n}{suffix}"

def print_lpf_configs_all_orders(f_cutoff, standard_capacitors_pf, standard_inductors_uh):
    for order in range(7, 0, -1):
        precise_config, approx_config = calculate_lpf(f_cutoff, standard_capacitors_pf, standard_inductors_uh, order)

        print(f" {ordinal(order)} = ({precise_config['error']:.2f}% error, {sum(len(v[0]) for k, v in precise_config.items() if k != 'error')} parts):", end="")
        for key, value in precise_config.items():
            if key != 'error':
                combination, error, comb_type = value
                if key.startswith('C'):
                    format_func = lambda x: format_capacitance_value(convert_pf_to_f(x))
                else:
                    format_func = lambda x: format_inductance_value(convert_uh_to_h(x))

                if comb_type == 'series':
                    component_str = ' + '.join(format_func(c) for c in combination)
                elif comb_type == 'parallel':
                    component_str = ' || '.join(format_func(c) for c in combination)
                else:
                    component_str = format_func(combination[0])

                total_value = sum(combination) if comb_type == 'series' else 1 / sum(1/c for c in combination) if comb_type == 'parallel' else combination[0]
                print(f" {key}_lpf={format_func(total_value)} ({component_str})", end="")
        print()

        print(f" {ordinal(order)} ≈ ({approx_config['error']:.2f}% error, {sum(len(v[0]) for k, v in approx_config.items() if k != 'error')} parts):", end="")
        for key, value in approx_config.items():
            if key != 'error':
                combination, error, comb_type = value
                if key.startswith('C'):
                    format_func = lambda x: format_capacitance_value(convert_pf_to_f(x))
                else:
                    format_func = lambda x: format_inductance_value(convert_uh_to_h(x))

                component_str = format_func(combination[0])
                print(f" {key}_lpf={component_str}", end="")
        print()

def find_top_component_combinations(target_value, standard_values, max_components=3, top_n=3):
    all_combinations = []
    for n in range(1, max_components + 1):
        for combination in itertools.combinations_with_replacement(standard_values, n):
            series_value = sum(combination)
            parallel_value = 1 / sum(1/c for c in combination)

            series_error = abs(target_value - series_value) / target_value * 100
            parallel_error = abs(target_value - parallel_value) / target_value * 100

            all_combinations.append((combination, series_error, 'series'))
            all_combinations.append((combination, parallel_error, 'parallel'))

    return sorted(all_combinations, key=lambda x: x[1])[:top_n]

def are_configs_similar(config1, config2, threshold=0.1):
    if set(config1.keys()) != set(config2.keys()):
        return False
    for key in config1.keys():
        if key != 'error':
            comb1, _, _ = config1[key]
            comb2, _, _ = config2[key]
            if abs(sum(comb1) - sum(comb2)) / sum(comb1) > threshold:
                return False
    return True

def print_lpf_configs(configs):
    print("\n Low Pass Filter Configurations:")
    for i, config in enumerate(configs):
        config_type = "Precise configuration" if i == 0 else f"Approximate configuration {i}"
        parts_count = sum(len(v[0]) for k, v in config.items() if k != 'error')
        print(f"  {config_type} ({config['error']:.2f}% error, {parts_count} parts):")
        for key, value in config.items():
            if key != 'error':
                combination, error, comb_type = value
                if key.startswith('C'):
                    format_func = lambda x: format_capacitance_value(convert_pf_to_f(x))
                else:
                    format_func = lambda x: format_inductance_value(convert_uh_to_h(x))

                if comb_type == 'series':
                    component_str = ' + '.join(format_func(c) for c in combination)
                elif comb_type == 'parallel':
                    component_str = ' || '.join(format_func(c) for c in combination)
                else:
                    component_str = format_func(combination[0])

                total_value = sum(combination) if comb_type == 'series' else 1 / sum(1/c for c in combination) if comb_type == 'parallel' else combination[0]
                print(f"   {key}: {format_func(total_value)} ({component_str})")

# old
#def l_network(f, Z_out):
#    L_match = math.sqrt(Z_out * (50 - Z_out)) / (2 * math.pi * f)
#    C_match = 1 / (2 * math.pi * f * math.sqrt(Z_out * (50 - Z_out)))
#    return L_match, C_match

def pi_network(f, Z_source, Z_load):
    w = 2 * math.pi * f
    Q = math.sqrt((Z_load / Z_source) - 1)

    XC1 = Z_source / Q
    XL = Q * Z_load
    XC2 = Z_load / Q

    L_match = XL / w
    C1_match = 1 / (w * XC1)
    C2_match = 1 / (w * XC2)

    # Convert to µH and pF for display
    L_match_uh = L_match * 1e6
    C1_match_pf = C1_match * 1e12
    C2_match_pf = C2_match * 1e12

    return C1_match, L_match, C2_match, L_match_uh, C1_match_pf, C2_match_pf

def l_network(f, Z_source, Z_load):
    w = 2 * math.pi * f

    debug_print(f"l_network input: f={f}, Z_source={Z_source}, Z_load={Z_load}")

    if Z_load > Z_source:
        # Step-up transformation
        Q = math.sqrt((Z_load / Z_source) - 1)
        XL = Q * Z_source
        XC = Z_load / Q
    else:
        # Step-down transformation
        Q = math.sqrt((Z_source / Z_load) - 1)
        XC = Z_source / Q
        XL = Q * Z_load

    L_match = XL / w
    C_match = 1 / (w * XC)

    debug_print(f"l_network calculations:")
    debug_print(f"  Q = {Q}")
    debug_print(f"  XL = {XL} ohms")
    debug_print(f"  L_match = {L_match*1e6:.3f} µH")  # Convert to µH for display
    debug_print(f"  XC = {XC} ohms")
    debug_print(f"  C_match = {C_match*1e12:.3f} pF")  # Convert to pF for display

    return L_match, C_match

def t_network(f, Z_source, Z_load):
    w = 2 * math.pi * f

    debug_print(f"t_network input: f={f}, Z_source={Z_source}, Z_load={Z_load}")

    # Use a default Q of 1.5 for T-network
    Q = 1.5

    XL1 = Q * Z_source
    XL2 = Q * Z_load
    XC = Q * (Z_source + Z_load) / (Q * Q + 1)

    L1_match = XL1 / w
    L2_match = XL2 / w
    C_match = 1 / (w * XC)

    debug_print(f"t_network calculations:")
    debug_print(f"  Q = {Q}")
    debug_print(f"  XL1 = {XL1} ohms")
    debug_print(f"  L1_match = {L1_match*1e6:.3f} µH")  # Convert to µH for display
    debug_print(f"  XL2 = {XL2} ohms")
    debug_print(f"  L2_match = {L2_match*1e6:.3f} µH")  # Convert to µH for display
    debug_print(f"  XC = {XC} ohms")
    debug_print(f"  C_match = {C_match*1e12:.3f} pF")  # Convert to pF for display

    return L1_match, C_match, L2_match


# old - but returned mH scale inductors
#def pi_network(f, Z_out):
#    Q = 1.5  # Quality factor, can be adjusted
#    C1_match = (Q / (2 * math.pi * f * 50)) * (1 + math.sqrt(1 + (50 / Z_out)))
#    L_match = (Q * 50) / (2 * math.pi * f)
#    C2_match = (Q / (2 * math.pi * f * Z_out)) * (1 + math.sqrt(1 + (Z_out / 50)))
#    #print(f"\nReturning pi_network(C1_match={C1_match},L_match={L_match},C2_match={C2_match}")
#    return C1_match, L_match, C2_match

# old
#def t_network(f, Z_out):
#    Q = 1.5  # Quality factor, can be adjusted
#    L1_match = (Q * 50) / (2 * math.pi * f)
#    C_match = Q / (2 * math.pi * f * math.sqrt(50 * Z_out))
#    L2_match = (Q * Z_out) / (2 * math.pi * f)
#    return L1_match, C_match, L2_match

def l_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== L Matching Network ===========================|===
 |                                                    |
 `--[L_match]--+------.                               |
               |      |                               |
           [C_match]  |                               |
               |      |                               |
              GND     |                               |
                      |                               |
 .--------------------'                               |
 | Z=50Ω                                              |"""

def pi_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== Pi Matching Network ==========================|===
 |                                                    |
 `--[C1_match]--[L_match]--[C2_match]--.              |
       |                      |        |              |
      GND                    GND       |              |
                                       |              |
 .-------------------------------------'              |
 | Z=50Ω                                              |"""

def t_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== T Matching Network ===========================|===
 |                                                    |
 `--[L1_match]--+--[L2_match]--.                      |
                |              |                      |
            [C_match]          |                      |
                |              |                      |
               GND             |                      |
                               |                      |
 .-----------------------------'                      |
 | Z=50Ω                                              |"""

def lpf_diagram():
    return """
=|===== Low Pass Filter ==============================|===
 |                                                    |
 `--[C1_lpf]--[L2_lpf]--[C3_lpf]--[L4_lpf]--[C5_lpf]--'
       |                   |                   |      
      GND                 GND                 GND     

==========================================================
"""

def generate_topology_diagram(matching_network_type, lpf_order=5):
    diagram = """
                                                  ANTENNA
                                                  SYSTEM
                                                   |  |
======= Class E Power Amplifier ===================|==|===
                                                   |  |
   VCC--[L1]--[C1]--[C2]--[L2]--.       DRV--[MOSFET] |
               |                |               |     |
              GND               |              GND    |
                                |                     |
                                |                     |
 .------------------------------'                     |"""
    
    #diagram += "\nMatching Network:\n"
    if matching_network_type == 'l':
        diagram += l_network_diagram()
    elif matching_network_type == 'pi':
        diagram += pi_network_diagram()
    elif matching_network_type == 't':
        diagram += t_network_diagram()
    
    #diagram += "\nLow Pass Filter:\n"
    diagram += lpf_diagram()
    
    return diagram

def print_matching_network_config(config, config_name):
    parts_count = sum(len(value[0]) for key, value in config.items() if key not in ['error', 'type'])
    print(f"    {config_name} ({config['error']:.2f}% error, {parts_count} parts):")
    for key, value in config.items():
        if key not in ['error', 'type']:
            combination, error, comb_type = value

            if key.startswith('C'):
                format_func = lambda x: format_capacitance_value(convert_pf_to_f(x))
            else:
                format_func = lambda x: format_inductance_value(convert_uh_to_h(x))  # Make sure this conversion is correct

            if comb_type == 'series':
                component_str = ' + '.join(format_func(c) for c in combination)
            elif comb_type == 'parallel':
                component_str = ' || '.join(format_func(c) for c in combination)
            else:  # single component
                component_str = format_func(combination[0])

            total_value = sum(combination) if comb_type == 'series' else 1 / sum(1/c for c in combination) if comb_type == 'parallel' else combination[0]
            formatted_value = format_func(total_value)
            print(f"      {key}: {formatted_value} ({component_str})")

def calculate_matching_network(topology, network_type, f):
    R_source = topology['R']
    Z_load = 50  # Assuming 50 ohm system impedance

    debug_print(f"calculate_matching_network input: topology={topology}, network_type={network_type}, f={f}")
    debug_print(f"Source impedance R: {R_source}, Load impedance: {Z_load}")

    if network_type == 'pi':
        C1_match, L_match, C2_match, L_match_uh, C1_match_pf, C2_match_pf = pi_network(f, R_source, Z_load)
        debug_print(f"calculate_matching_network ('pi' topology) returning C1_match:{C1_match_pf:.3f}pF, L_match:{L_match_uh:.3f}µH, C2_match:{C2_match_pf:.3f}pF")
        return [('C1_match', C1_match), ('L_match', L_match), ('C2_match', C2_match)]
    elif network_type == 'l':
        L_match, C_match = l_network(f, R_source, Z_load)
        debug_print(f"calculate_matching_network ('l' topology) returning L_match:{L_match*1e6:.3f}µH, C_match:{C_match*1e12:.3f}pF")
        return [('L_match', L_match), ('C_match', C_match)]
    elif network_type == 't':
        L1_match, C_match, L2_match = t_network(f, R_source, Z_load)
        debug_print(f"calculate_matching_network ('t' topology) returning L1_match:{L1_match*1e6:.3f}µH, C_match:{C_match*1e12:.3f}pF, L2_match:{L2_match*1e6:.3f}µH")
        return [('L1_match', L1_match), ('C_match', C_match), ('L2_match', L2_match)]
    else:
        raise ValueError("Invalid network type. Choose 'L', 'Pi', or 'T'.")

def generate_configuration_string(config_groups):
    return ' || '.join(' + '.join(format_inductance_value(ind) for ind in group) for group in config_groups)

#def generate_configuration_string(config):
#    debug_print("Generating configuration string")
#    parts = []
#    for group in config:
#        group_parts = []
#        for inductor in group:
#            ind_value_h = parse_inductance(inductor)
#            debug_print(f"Processing inductor {inductor} as {ind_value_h}H")
#            srf, dcr, idc = get_inductor_properties(ind_value_h)
#            if srf is not None:
#                debug_print(f"Properties for {format_inductance_value(ind_value_h)}: SRF {format_frequency_value(srf*1e6)}, DCR {format_resistance_value(dcr)}, IDC {format_current_value(idc*1e-3)}")
#                group_parts.append(f"{format_inductance_value(ind_value_h)} (SRF {format_frequency_value(srf*1e6)}, DCR {format_resistance_value(dcr)}, IDC {format_current_value(idc*1e-3)})")
#            else:
#                debug_print(f"No properties found for {format_inductance_value(ind_value_h)}")
#                group_parts.append(f"{format_inductance_value(ind_value_h)} (No data available)")
#        parts.append(" + ".join(group_parts))
#    return " || ".join(parts)

def create_parser():
    parser = argparse.ArgumentParser(description='Class-E RF Power Amplifier Calculator')
    
    parser.add_argument('-p', '--power', type=float, help='Output power in watts')
    parser.add_argument('-v', '--voltage', type=float, help='Supply voltage')
    parser.add_argument('-b', '--bands', nargs='+', choices=AVAILABLE_BANDS, metavar='BANDLIST', help='Amateur radio band(s) (eg. 20m 40m)')
    parser.add_argument('-t', '--type', choices=['infinite', 'finite', 'inverse'], default='infinite', help='Topology type selection')
    parser.add_argument('-q', '--q-factor', type=float, help='Q factor (optional)')
    parser.add_argument('-m', '--mosfet', choices=AVAILABLE_MOSFETS, metavar='MOSFET', help='MOSFET')
    parser.add_argument('-M', '--matching', choices=['l', 'pi', 't'], default='pi', help='Matching network type')
    parser.add_argument('--list-bands', action='store_true', help='List available bands and exit')
    parser.add_argument('--list-mosfets', action='store_true', help='List available MOSFETs and exit')
    parser.add_argument('--l1', type=str, help='Specify L1 value (e.g., 10uh)')
    #parser.add_argument('--c1', type=str, help='Specify C1 value (e.g., 100pf)')
    #parser.add_argument('--c2', type=str, help='Specify C2 value (e.g., 50pf)')
    #parser.add_argument('--l2', type=str, help='Specify L2 value (e.g., 5uh)')
    parser.add_argument('--r', type=float, help='Specify load resistance (ohms)')
    parser.add_argument('--duty-cycle', type=float, default=0.5, help='Duty cycle (default: 0.5)')
    parser.add_argument('--efficiency', type=float, default=0.85, help='Efficiency (default: 0.85)')
    parser.add_argument("--equivalent-inductor", help="Generate a series-parallel network at the target inductor value (and frequency band)")
    parser.add_argument("--equivalent-inductor-max-components", type=int, default=5, help="Maximum number of components in a proposed configuration")
    parser.add_argument('--equivalent-inductor-min-current', type=str, help='Minimum current required for equivalent inductor configurations (eg: \'420mA\')')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    
    return parser

def parse_arguments():
    parser = create_parser()
    args = parser.parse_args()
    return args

def test_estimate_srf():
    inductors = [
        0.001, 0.0015, 0.0022, 0.0033, 0.0047, 0.0068, 0.0082,
        0.01, 0.012, 0.015, 0.018, 0.022, 0.027, 0.033, 0.039, 0.047, 0.056, 0.068, 0.082,
        0.1, 0.12, 0.15, 0.18, 0.22, 0.27, 0.33, 0.39, 0.47, 0.56, 0.68, 0.82,
        1, 1.2, 1.5, 1.8, 2.2, 2.7, 3.3, 3.9, 4.7, 5.6, 6.8, 8.2,
        10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82, 100,
        120, 150, 180, 220, 270, 330, 390, 470, 560, 680, 820, 1000
    ]

    print("Testing revised estimate_srf() function:")
    print("Inductance | Estimated SRF")
    print("-----------|--------------")

    for inductance in inductors:
        srf = estimate_srf(inductance * 1e-6)  # Convert µH to H
        print(f"{inductance:9.3f}µH | {format_frequency_value(srf)}")

# Call the test function
#test_estimate_srf()

def main():
    global debug_enabled
    args = parse_arguments()
    debug_enabled = args.debug

    matching_network_type = args.matching.lower() if args.matching else 'pi'

    # First, clear the exclusive modes
    # --equivalent-inductor '1uh' --bands 20m
    if args.equivalent_inductor:

        debug_print(f"Equivalent inductor mode activated with value: {args.equivalent_inductor}")
        inductors = [i * 1e-6 for i in COMPONENTS['inductors_uh']]  # Convert to Henry
        debug_print(f"Available inductors: {inductors}")
        if args.equivalent_inductor_min_current:
            min_current = parse_current(args.equivalent_inductor_min_current)
            min_current_string = f" (I≥{format_current_value(min_current)})"
        else:
            min_current = None
            min_current_string = ""
        debug_print(f"Minimum current requirement: {min_current}")
        debug_print(f"Requesting configs...")
        target_value = float(parse_inductance(args.equivalent_inductor))
        configs = generate_inductor_configurations(
            target_value,
            inductors,
            FREQUENCY_BANDS,
            max_components=args.equivalent_inductor_max_components,
            max_configurations=30,
            bands=args.bands,
            min_current=min_current
        )
        debug_print(f"Received configs: {configs}")

        max_freq = get_max_frequency(args.bands)
        formatted_bands = ', '.join(format_band_with_range(band) for band in args.bands)

        if configs:
            print(f"Configurations for {format_inductance_value(target_value)} on bands {formatted_bands} with maximum operating frequency {max_freq}MHz{min_current_string}:")

            for i, config_tuple in enumerate(configs, 1):
                config_groups = config_tuple[0]
                value = config_tuple[1]
                srf = config_tuple[2]
                
                parts = sum(len(group) for group in config_groups)
                unique_parts = count_unique_parts(config_tuple)
                accuracy = 100 * (1 - abs(value - target_value) / target_value)

                # Calculate total DCR and IDC
                total_dcr = 0
                total_idc = float('inf')
    
                for group in config_groups:
                    group_dcr = sum(get_inductor_properties(ind)[1] for ind in group)
                    group_idc = min(get_inductor_properties(ind)[2] for ind in group)
                    total_dcr += group_dcr
                    total_idc = min(total_idc, group_idc)

                print(f"{i}. Accuracy: {accuracy:.2f}%, Parts: {parts}, Unique parts: {unique_parts}, SRF: {format_frequency_value(convert_mhz_to_hz(srf))}, DCR: {format_resistance_value(total_dcr)}, IDC: {format_current_value(convert_ma_to_a(total_idc))}")
    
                config_str = generate_configuration_string(config_groups)
                print(f"   Configuration: {config_str}")
                print()
        else:
            print("No valid configurations found.")

        sys.exit(0)
    # --list-bands
    if args.list_bands:
        list_available_bands(FREQUENCY_BANDS)
        return
    # --list-mosfets
    elif args.list_mosfets:
        list_available_mosfets(MOSFETS)
        return

    # Check for required arguments for main operation
    if not all([args.power, args.voltage, args.bands, args.mosfet]):
        print("Error: The following arguments are required: -p/--power, -v/--voltage, -b/--bands, -m/--mosfet")
        sys.exit(1)

    if args.mosfet not in MOSFETS:
        print(f"Error: MOSFET '{args.mosfet}' not found")
        sys.exit(1)

    mosfet_data = MOSFETS[args.mosfet]
    mosfet_info = f"{args.mosfet} (Vdss={mosfet_data['vdss_v']}V, Id={mosfet_data['id_a']}A, Rds_on={mosfet_data['rds_on_o']}Ω, Ciss={mosfet_data['ciss_pf']}pF, Coss={mosfet_data['coss_pf']}pF, Crss={mosfet_data['crss_pf']}pF, Vgs_th={mosfet_data['vgs_th_v']}V)"

    print( "Command line:", " ".join(sys.argv))
    utc_date = get_utc_date()
    print(f"UTC datetime: {utc_date}")

    print("\nInput parameters:")
    print(f" Output Power = {format_power_value(args.power)}")
    print(f" Supply Voltage = {format_voltage_value(args.voltage)}")
    print(f" MOSFET = {mosfet_info}")
    print(f" Q Factor = {args.q_factor}")

    band_ids = args.bands #.split(',')

    generator = ClassETopologyGenerator()

    for band_id in band_ids:
        if band_id not in FREQUENCY_BANDS:
            print(f"Warning: Band '{band_id}' not found in known frequency bands. Skipping.")
            continue

        band_data = FREQUENCY_BANDS[band_id]
        center_freq, bandwidth = calculate_center_frequency_and_bandwidth(band_data)

        if args.q_factor is None:
            q_factor = calculate_auto_q(band_data)
        else:
            q_factor = args.q_factor

        args.l1 = parse_inductance(args.l1)

        if args.type == "infinite":
            topology = generator.class_e_topology_generate_infinite(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)
        elif args.type == "finite":
            topology = generator.class_e_topology_generate_finite(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)
        elif args.type == "inverse":
            topology = generator.class_e_topology_generate_inverse(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)

        operating_params = generator.calculate_operating_parameters(args.voltage, center_freq, q_factor, topology['R'])

        print(f"\n[{band_id}] @ {format_frequency_value(band_data['start'] * 1e6)}-{format_frequency_value(band_data['end'] * 1e6)} (c={format_frequency_value(center_freq)}, nbw={format_frequency_value(bandwidth)}, bw={format_frequency_value(operating_params['bandwidth'])}, q={format_number(q_factor)})")
        print(f" Power Amplifier components:")
        print(f"  Topology = {args.type}")
        debug_print(f"args.l1={args.l1}")
        if args.type == "infinite":
            if topology['L1_status'] == "user-specified":
                print(f"  L1 = {format_inductance_value(topology['L1'])} (user-specified)")
            else:
                print(f"  L1 ≥ {format_inductance_value(topology['L1'])} (calculated)")
        else:
            print(f"  L1 = {format_inductance_value(topology['L1'])} ({topology['L1_status']})")
        print(f"  L2 = {format_inductance_value(topology['L2'])}")
        print(f"  C1 = {format_capacitance_value(topology['C1'])}")
        print(f"  C2 = {format_capacitance_value(topology['C2'])}")
        print(f"  R = {format_resistance_value(topology['R'])} (before matching)")

        best_configs = find_best_configurations(topology['L2'], topology['C1'], topology['C2'], center_freq)





        print("\n  Top 3 recommended Power Amplifier component configurations:")
        for i, config in enumerate(best_configs, 1):
            L2, C1, C2, L2_type, L2_desc, C1_type, C1_desc, C2_type, C2_desc, error, srf_margin, component_count = config
            esr_mult = esr_multiplier(L2_type, 2 if L2_type != 'single' else 1)
            current_mult = current_multiplier(L2_type, 2 if L2_type != 'single' else 1)
            srf_ok, srf_status = check_srf_margin(srf_margin)
            print(f"\n   Configuration {i}: ({format_percentage(error)} error, estimated SRF margin {format_number(srf_margin)} ({srf_status}), {component_count} parts)")
            if not srf_ok:
                print("   (SRF Concern: Consider using a different inductor or parallel combination for L2)")
            print(f"     L2 = {format_inductance_value(L2)} ({L2_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")
            esr_mult = esr_multiplier(C1_type, 2 if C1_type != 'single' else 1)
            current_mult = current_multiplier(C1_type, 2 if C1_type != 'single' else 1)
            print(f"     C1 = {format_capacitance_value(C1)} ({C1_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")
            esr_mult = esr_multiplier(C2_type, 2 if C2_type != 'single' else 1)
            current_mult = current_multiplier(C2_type, 2 if C2_type != 'single' else 1)
            print(f"     C2 = {format_capacitance_value(C2)} ({C2_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")

        # ------------------------------------------------------------------------------------
        # determine matching network
        #matching_components = calculate_matching_network(center_freq, topology['C1'], matching_network_type)
        #tolerance=0.1 # 10%
        # ----------------------------------------------------

        matching_network = calculate_matching_network(topology, matching_network_type, center_freq)
        debug_print(f"matching_network = {matching_network}")
        configs = generate_matching_network_configs(matching_network, matching_network_type, COMPONENTS['capacitors_pf'], COMPONENTS['inductors_uh'], center_freq)

        # Sort configurations by accuracy (lowest error first)
        sorted_configs = sorted(configs, key=lambda x: x['error'])

        # Display results
        print(f"\nMatching Network Configurations ({matching_network_type} topology):")
        for config in sorted_configs:
            print_matching_network_config(config, "Precise configuration" if config['type'] == 'precise' else f"Approximate configuration {sorted_configs.index(config)}")

        # ----------------------------------------------------
        debug_print("About to calculate LPF")
        f_cutoff = center_freq * 1.5  # Make sure this line is present
        debug_print(f"f_cutoff = {f_cutoff}")
        # ----------------------------------------------------

        #lpf_configs = calculate_lpf(f_cutoff,COMPONENTS['capacitors_pf'],COMPONENTS['inductors_uh'])
        #print_lpf_configs(lpf_configs)

        print("\nLow Pass Filter Configurations:")
        print_lpf_configs_all_orders(f_cutoff, COMPONENTS['capacitors_pf'], COMPONENTS['inductors_uh'])

        # ---------------------------------------------------

        # Generate and print the topology diagram
        topology_diagram = generate_topology_diagram(matching_network_type)
        print(topology_diagram)

if __name__ == "__main__":
    main()
