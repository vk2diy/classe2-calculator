#!/usr/bin/python
import argparse
import math
import json
import re
from bisect import bisect_left
from collections import OrderedDict
import itertools

class ClassETopologyGenerator:

    def __init__(self):
        self.pi = math.pi

    def class_e_topology_generate_inverse(self, power, voltage, center_freq, bandwidth, mosfet_data, q_factor, L1=None):
        omega = 2 * math.pi * center_freq
        L1_min = 0.1 * voltage**2 / (omega * power)
        if L1 is None:
            L1 = L1_min
            L1_status = "calculated"
        else:
            L1_status = "user-specified"
            L1 = parse_inductance(L1)
            if L1 < L1_min:
                print(f"Warning: User-specified L1 ({L1:.2e}H) is less than the calculated minimum ({L1_min:.2e}H)")

        if L1 < L1_min:
            raise ValueError(f"L1 is too small. Minimum value: {L1_min:.3e} H")
        R = 0.5768 * voltage**2 / power
        C2 = 0.1836 / (omega * R)
        C1 = 1 / (omega**2 * L1) - C2
        L2 = R / (omega * 1.1525)
        if q_factor is None:
            q_factor = math.sqrt(L1 / C1) / R
        duty_cycle = 0.5
        efficiency = 0.9  # Theoretical maximum for Class E

        return { 'L1': L1, 'C1': C1, 'R': R, 'C2': C2, 'L2': L2, 'Q': q_factor, 'duty_cycle': duty_cycle, 'efficiency': efficiency, "L1_status": L1_status, "L1_min": L1_min }

    def class_e_topology_generate_infinite(self, output_power_watts, pa_voltage_volts, center_frequency_hz, bandwidth_hz, mosfet_data, Q, L1=None):
        w0 = 2 * math.pi * center_frequency_hz

        Vo = 0  # Assume 0V for MOSFETs
        Coss = mosfet_data['coss_pf'] * 1e-12

        R = 0.576801 * ((pa_voltage_volts - Vo)**2 / output_power_watts) * (1.0000086 - (0.414396 / Q) - (0.577501 / (Q**2)) + (0.205967 / (Q**3)))

        L1_min = ((math.pi**2 + 4) * R) / w0

        if L1 is None:
            L1 = ((math.pi**2 + 4) * R) / w0  # Minimum value for L1
            L1_status = "calculated"
        else:
            L1_status = "user-specified"
            L1 = parse_inductance(L1)
            if L1 < L1_min:
                print(f"Warning: User-specified L1 ({L1:.2e}H) is less than the calculated minimum ({L1_min:.2e}H)")

        # C1 calculation uses Raab's 2001 formula
        C1 = (1 / (34.2219 * center_frequency_hz * R)) * (0.99866 + (0.91424 / Q) - (1.03175 / (Q**2))) + (0.6 / ((2 * math.pi * center_frequency_hz)**2 * L1))
        L2 = (Q * R) / w0
        C2 = (1 / (w0 * R)) * (1 / (Q - 0.104823)) * (1.00121 + 1.01468 / (Q - 1.7879))

        return { "L1": L1, "L2": L2, "C1": C1, "C2": C2, "R": R, "L1_status": L1_status, "L1_min": L1_min }

    def class_e_topology_generate_finite(self, output_power_watts, pa_voltage_volts, center_frequency_hz, bandwidth_hz, mosfet_data, Q, L1=None):
        w0 = 2 * self.pi * center_frequency_hz

        Vo = 0  # Assume 0V for MOSFETs
        Coss = mosfet_data['coss_pf'] * 1e-12

        R = 0.576801 * ((pa_voltage_volts - Vo)**2 / output_power_watts) * (1.0000086 - (0.414396 / Q) - (0.577501 / (Q**2)) + (0.205967 / (Q**3)))
        C1 = (1 / (34.2219 * center_frequency_hz * R)) * (0.99866 + (0.91424 / Q) - (1.03175 / (Q**2))) - Coss
        L2 = (1.15 * R) / w0
        C2 = (1 / (w0 * R)) * (1 / (Q - 0.104823)) * (1.00121 + 1.01468 / (Q - 1.7879))

        if L1 is None:
            L1 = (0.1836 * R) / w0
            L1_status = "calculated"
        else:
            L1_optimal = (0.1836 * R) / w0
            L1_status = "user-specified"
            if abs(L1 - L1_optimal) / L1_optimal > 0.1:  # If L1 differs by more than 10% from optimal
                print(f"Warning: User-specified L1 ({L1:.2e}H) differs significantly from the calculated optimal value ({L1_optimal:.2e}H)")

        return { "L1": L1, "L2": L2, "C1": C1, "C2": C2, "R": R, "L1_status": L1_status }

    def calculate_operating_parameters(self, pa_voltage_volts, center_frequency_hz, Q, R):
        peak_vds = pa_voltage_volts * 3.56 / 0.8
        bandwidth = center_frequency_hz / Q
        # Estimate harmonics (simplified model)
        # These are rough estimates and may not be accurate for all designs
        second_harmonic = -20 * math.log10(Q)  # dB below fundamental
        third_harmonic = -30 * math.log10(Q)   # dB below fundamental
        # Calculate drain efficiency (simplified estimate)
        # This is a theoretical maximum, actual efficiency will be lower
        drain_efficiency = 100 * (math.pi**2 / 4 + 1) / (math.pi**2 / 2 + 2)  # in percentage
        # Calculate maximum drain current (simplified estimate)
        max_drain_current = (2 * math.pi * pa_voltage_volts) / (math.pi**2 * R)

        return { "peak_vds": peak_vds, "bandwidth": bandwidth, "second_harmonic": second_harmonic, "third_harmonic": third_harmonic, "drain_efficiency": drain_efficiency, "max_drain_current": max_drain_current }

from itertools import combinations_with_replacement

def load_components(filename='components.json'):
    with open(filename, 'r') as f:
        return json.load(f)

COMPONENTS = load_components()

def estimate_srf(inductance):
    return 150e6 / math.sqrt(inductance * 1e6)

def parallel_combination(v1, v2):
    return (v1 * v2) / (v1 + v2)

def series_combination(*values):
    return sum(values)

def generate_combinations(target_values, components, max_parts=3, tolerance=0.1):
    def generate_for_single(target, components):
        configurations = []
        for i in range(1, max_parts + 1):
            for combo in itertools.combinations_with_replacement(components, i):
                value = sum(combo)
                error = abs(value - target) / target
                if error <= tolerance:
                    esr_factor = i
                    current_factor = 1 / i
                    configurations.append((error, combo, esr_factor, current_factor))
        return sorted(configurations, key=lambda x: x[0])[:3]

    all_configs = [generate_for_single(target, components[component_type])
                   for component_type, target in target_values.items()]

    return list(itertools.product(*all_configs))

def format_configuration(config, component_type):
    error, parts, esr_factor, current_factor = config
    if component_type == 'L':
        formatted_value = format_inductance_value(sum(parts) * 1e-6)
        parts_str = ' + '.join(format_inductance_value(p * 1e-6) for p in parts)
    else:  # component_type == 'C'
        formatted_value = format_capacitance_value(sum(parts) * 1e-12)
        parts_str = ' + '.join(format_capacitance_value(p * 1e-12) for p in parts)

    # Determine ESR description
    if esr_factor == 1:
        esr_desc = "ESR=standard"
    elif esr_factor < 1:
        esr_desc = "ESR=reduced"
    else:
        esr_desc = f"ESR=sum"

    # Determine current handling description
    if current_factor == 1:
        current_desc = "I=normal"
    elif current_factor == 0.5:
        current_desc = "I=half"
    elif current_factor < 1:
        current_desc = f"I=smallest"
    else:
        current_desc = f"I={current_factor:.2f}x(?)"

    return f"({error:.2f}% error) {formatted_value} ({parts_str}) [{esr_desc}] [{current_desc}]"

def evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq):
    L2_error = abs(L2 - target_L2) / target_L2
    C1_error = abs(C1 - target_C1) / target_C1
    C2_error = abs(C2 - target_C2) / target_C2
    total_error = L2_error + C1_error + C2_error
    
    L2_srf = estimate_srf(L2)
    srf_margin = L2_srf / center_freq
    
    return total_error, srf_margin

def find_closest(arr, target):
    pos = bisect_left(arr, target)
    if pos == 0:
        return arr[0]
    if pos == len(arr):
        return arr[-1]
    before = arr[pos - 1]
    after = arr[pos]
    if after - target < target - before:
        return after
    else:
        return before

def evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq):
    L2_error = abs(L2 - target_L2) / target_L2
    C1_error = abs(C1 - target_C1) / target_C1
    C2_error = abs(C2 - target_C2) / target_C2
    total_error = L2_error + C1_error + C2_error

    L2_srf = estimate_srf(L2)
    srf_margin = L2_srf / center_freq

    return total_error, srf_margin

def find_combinations(target, values, max_components=2, tolerance=0.05, is_inductor=False):
    combinations = []

    # Single component
    closest = find_closest(values, target)
    combinations.append((closest, 'single', f'{format_number(closest)}'))

    if max_components >= 2:
        # Parallel combinations
        for i, v1 in enumerate(values):
            for v2 in values[i:]:
                combined = parallel_combination(v1, v2)
                if abs(combined - target) / target <= tolerance:
                    v1_str = format_inductance_value(v1) if is_inductor else format_capacitance_value(v1)
                    v2_str = format_inductance_value(v2) if is_inductor else format_capacitance_value(v2)
                    combinations.append((combined, 'parallel', f'{v1_str} || {v2_str}'))

        # Series combinations
        for i, v1 in enumerate(values):
            for v2 in values[i:]:
                combined = series_combination(v1, v2)
                if abs(combined - target) / target <= tolerance:
                    v1_str = format_inductance_value(v1) if is_inductor else format_capacitance_value(v1)
                    v2_str = format_inductance_value(v2) if is_inductor else format_capacitance_value(v2)
                    combinations.append((combined, 'series', f'{v1_str} + {v2_str}'))

    combinations.sort(key=lambda x: abs(x[0] - target))
    return combinations[:5]  # Return top 5 combinations

def check_srf_margin(srf_margin):
    return srf_margin >= 3, "Good" if srf_margin >= 3 else "Concern"

def esr_multiplier(config_type, component_count):
    if config_type == 'single':
        return 1
    elif config_type == 'series':
        return component_count
    elif config_type == 'parallel':
        return 1 / component_count
    else:
        return 1  # Default case

def current_multiplier(config_type, component_count):
    if config_type == 'single':
        return 1
    elif config_type == 'series':
        return 1 / component_count
    elif config_type == 'parallel':
        return component_count
    else:
        return 1  # Default case

def find_best_configurations(target_L2, target_C1, target_C2, center_freq, num_results=3):
    L2_values = [x * 1e-6 for x in COMPONENTS['inductors_uh']]
    C_values = [x * 1e-12 for x in COMPONENTS['capacitors_pf']]

    L2_combinations = find_combinations(target_L2, L2_values, is_inductor=True)
    C1_combinations = find_combinations(target_C1, C_values, is_inductor=False)
    C2_combinations = find_combinations(target_C2, C_values, is_inductor=False)

    configurations = []
    for L2, L2_type, L2_desc in L2_combinations:
        for C1, C1_type, C1_desc in C1_combinations:
            for C2, C2_type, C2_desc in C2_combinations:
                error, srf_margin = evaluate_configuration(L2, C1, C2, target_L2, target_C1, target_C2, center_freq)
                component_count = sum(2 if config_type != 'single' else 1 for config_type in [L2_type, C1_type, C2_type])
                configurations.append((L2, C1, C2, L2_type, L2_desc, C1_type, C1_desc, C2_type, C2_desc, error, srf_margin, component_count))

    configurations.sort(key=lambda x: (x[9], -x[10], x[11]))  # Sort by error (ascending), SRF margin (descending), and component count (ascending)
    return configurations[:num_results]

def calculate_auto_q(band_data):
    f_lower = band_data['start'] * 1e6  # Convert to Hz
    f_upper = band_data['end'] * 1e6    # Convert to Hz
    f_center = (f_upper + f_lower) / 2
    natural_bandwidth = f_upper - f_lower
    desired_bandwidth = 1.2 * natural_bandwidth
    auto_q = f_center / desired_bandwidth
    return auto_q

def parse_inductance(value):
    if value is None:
        return None

    units = {'H': 1, 'MH': 1e-3, 'UH': 1e-6, 'NH': 1e-9, 'PH': 1e-12}
    pattern = r'^(\d+\.?\d*)([a-zA-Z]+)$'

    if isinstance(value, str):
        value = value.strip().upper()  # Convert to uppercase and remove whitespace
        match = re.match(pattern, value)

        if match:
            number, unit = match.groups()
            if unit in units:
                return float(number) * units[unit]

    try:
        return float(value)
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid inductance value: {value}")

def load_frequency_bands(filename='frequency_bands.json'):
    with open(filename, 'r') as f:
        return json.load(f)

# Get the list of available bands
AVAILABLE_BANDS = list(load_frequency_bands().keys())

def calculate_center_frequency_and_bandwidth(band_data):
    center_freq = (band_data['start'] + band_data['end']) / 2
    bandwidth = band_data['end'] - band_data['start']
    return center_freq * 1e6, bandwidth * 1e6  # Convert to Hz

def format_number_for_clarity(value_str):
    match = re.match(r'^(-?\d*\.?\d+)\s*(.*)$', value_str)
    if match:
        numeric_part, suffix = match.groups()
    else:
        return value_str

    # Remove trailing zeros after the decimal point for the numeric part
    if '.' in numeric_part:
        numeric_part = numeric_part.rstrip('0').rstrip('.')

    # If the result is just "0.", change it to "0"
    if numeric_part == "0.":
        numeric_part = "0"

    # Rejoin the numeric part with the suffix
    return numeric_part + suffix

def format_inductance_value(value):
    if value >= 1:
        return format_number_for_clarity(f"{value:.3f}H")
    elif value >= 1e-3:
        return format_number_for_clarity(f"{value*1e3:.3f}mH")
    elif value >= 1e-6:
        return format_number_for_clarity(f"{value*1e6:.3f}µH")
    else:
        return format_number_for_clarity(f"{value*1e9:.3f}nH")

def format_capacitance_value(value):
    if value >= 1e-3:
        return format_number_for_clarity(f"{value*1e3:.3f}mF")
    elif value >= 1e-6:
        return format_number_for_clarity(f"{value*1e6:.3f}µF")
    elif value >= 1e-9:
        return format_number_for_clarity(f"{value*1e9:.3f}nF")
    else:
        return format_number_for_clarity(f"{value*1e12:.3f}pF")

def format_resistance_value(value):
    if value >= 1e6:
        return format_number_for_clarity(f"{value/1e6:.3f}MΩ")
    elif value >= 1e3:
        return format_number_for_clarity(f"{value/1e3:.3f}kΩ")
    else:
        return format_number_for_clarity(f"{value:.3f}Ω")

def format_frequency_value(value):
    if value >= 1e9:
        return format_number_for_clarity(f"{value/1e9:.3f}GHz")
    elif value >= 1e6:
        return format_number_for_clarity(f"{value/1e6:.3f}MHz")
    elif value >= 1e3:
        return format_number_for_clarity(f"{value/1e3:.3f}kHz")
    else:
        return format_number_for_clarity(f"{value:.3f}Hz")

def format_voltage_value(value):
    if value >= 1e6:
        return format_number_for_clarity(f"{value/1e6:.3f}MV")
    elif value >= 1e3:
        return format_number_for_clarity(f"{value/1e3:.3f}kV")
    else:
        return format_number_for_clarity(f"{value:.3f}V")

def format_current_value(value):
    if value >= 1:
        return format_number_for_clarity(f"{value:.3f}A")
    elif value >= 1e-3:
        return format_number_for_clarity(f"{value*1e3:.3f}mA")
    elif value >= 1e-6:
        return format_number_for_clarity(f"{value*1e6:.3f}µA")
    else:
        return format_number_for_clarity(f"{value*1e9:.3f}nA")

def format_power_value(value):
    if value >= 1e9:
        return format_number_for_clarity(f"{value/1e9:.3f}GW")
    elif value >= 1e6:
        return format_number_for_clarity(f"{value/1e6:.3f}MW")
    elif value >= 1e3:
        return format_number_for_clarity(f"{value/1e3:.3f}kW")
    else:
        return format_number_for_clarity(f"{value:.3f}W")

def format_capacitance_series_string(target_value, component_list):
    components = recommend_components(target_value, component_list, False)
    if components:
        combo, error, total = components[0]
        return f"{'+'.join(format_capacitance_value(c*1e-12) for c in combo)} " \
               f"(total: {format_capacitance_value(total)}≈{format_capacitance_value(target_value)}±{format_percentage(error*100)})"
    return "No suitable combination found"

def format_capacitance_parallel_string(target_value, component_list):
    components = recommend_components(target_value, component_list, False)
    if components:
        combo, error, total = components[0]
        return f"{' || '.join(format_capacitance_value(c*1e-12) for c in combo)} " \
               f"(total: {format_capacitance_value(total)}≈{format_capacitance_value(target_value)}±{format_percentage(error*100)})"
    return "No suitable combination found"

def format_percentage(value):
    return format_number_for_clarity(f"{value:.2f}%")

def format_number(value, precision=3):
    if abs(value) < 1e-9:  # Treat very small numbers as zero
        return "0"
    formatted = f"{value:.{precision}f}"
    return formatted.rstrip('0').rstrip('.')


def list_available_bands(frequency_bands):
    for band_id, band_data in frequency_bands.items():
        start_freq = format_frequency_value(band_data['start'] * 1e6)
        end_freq = format_frequency_value(band_data['end'] * 1e6)
        print(f"{band_id}:{start_freq}-{end_freq}")

def load_mosfets(filename='mosfets.json'):
    with open(filename, 'r') as f:
        return json.load(f)

# Get the list of available MOSFETs
AVAILABLE_MOSFETS = list(load_mosfets().keys())

def list_available_mosfets(mosfets):
    print("Available MOSFETs:")
    sorted_mosfets = OrderedDict(sorted(mosfets.items()))
    for mosfet_id, mosfet_data in sorted_mosfets.items():
        mosfet_info = [
            mosfet_id,
            mosfet_data.get('lcsc', 'N/A'),
            f"{mosfet_data.get('vdss_v', 'N/A')}V",
            f"{mosfet_data.get('id_a', 'N/A')}A",
            f"{mosfet_data.get('rds_on_o', 'N/A')}Ω",
            f"{mosfet_data.get('ciss_pf', 'N/A')}pF",
            f"{mosfet_data.get('coss_pf', 'N/A')}pF",
            f"{mosfet_data.get('crss_pf', 'N/A')}pF",
            f"{mosfet_data.get('vgs_th_v', 'N/A')}V"
        ]
        print(":".join(mosfet_info))

def calculate_output_impedance(f, C1):
    return 0.28 / (2 * math.pi * f * C1)

def calculate_lpf(f_cutoff, order=5):
    # Normalized Butterworth coefficients for 5th order filter
    g_values = [1.0, 1.5963, 2.0967, 1.5963, 1.0]

    Z0 = 50  # Characteristic impedance in ohms
    omega_c = 2 * math.pi * f_cutoff

    components = []
    for i, g in enumerate(g_values):
        if i % 2 == 0:  # Shunt capacitors
            C = g / (Z0 * omega_c)
            components.append(('C', C))
        else:  # Series inductors
            L = (Z0 * g) / omega_c
            components.append(('L', L))

    return components

def l_network(f, Z_out):
    L_match = math.sqrt(Z_out * (50 - Z_out)) / (2 * math.pi * f)
    C_match = 1 / (2 * math.pi * f * math.sqrt(Z_out * (50 - Z_out)))
    return L_match, C_match

def pi_network(f, Z_out):
    Q = 1.5  # Quality factor, can be adjusted
    C1_match = (Q / (2 * math.pi * f * 50)) * (1 + math.sqrt(1 + (50 / Z_out)))
    L_match = (Q * 50) / (2 * math.pi * f)
    C2_match = (Q / (2 * math.pi * f * Z_out)) * (1 + math.sqrt(1 + (Z_out / 50)))
    #print(f"\nReturning pi_network(C1_match={C1_match},L_match={L_match},C2_match={C2_match}")
    return C1_match, L_match, C2_match

def t_network(f, Z_out):
    Q = 1.5  # Quality factor, can be adjusted
    L1_match = (Q * 50) / (2 * math.pi * f)
    C_match = Q / (2 * math.pi * f * math.sqrt(50 * Z_out))
    L2_match = (Q * Z_out) / (2 * math.pi * f)
    return L1_match, C_match, L2_match

def l_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== L Matching Network ===========================|=======
 |                                                    |
 `--[L_match]--+------.                               |
               |      |                               |
           [C_match]  |                               |
               |      |                               |
              GND     |                               |
                      |                               |
 .--------------------'                               |
 | Z=50Ω                                              |"""

def pi_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== Pi Matching Network ==========================|=======
 |                                                    |
 `--[C1_match]--[L_match]--[C2_match]--.              |
       |                      |        |              |
      GND                    GND       |              |
                                       |              |
 .-------------------------------------'              |
 | Z=50Ω                                              |"""

def t_network_diagram():
    return """
 | Z<50Ω                                              |
=|===== T Matching Network ===========================|=======
 |                                                    |
 `--[L1_match]--+--[L2_match]--.                      |
                |              |                      |
            [C_match]          |                      |
                |              |                      |
               GND             |                      |
                               |                      |
 .-----------------------------'                      |
 | Z=50Ω                                              |"""

def lpf_diagram():
    return """
=|===== Low Pass Filter ==============================|=======
 |                                                    |
 `--[C1_lpf]--[L2_lpf]--[C3_lpf]--[L4_lpf]--[C5_lpf]--'
       |                   |                   |      
      GND                 GND                 GND     

==============================================================
"""

def generate_topology_diagram(matching_network_type, lpf_order=5):
    diagram = """
                                                  ANTENNA
                                                  SYSTEM
                                                   |  |
======= Class E Power Amplifier ===================|==|=======
   VCC--[L1]--[C1]--[C2]--[L2]--.                  |  |
               |                |       DRV--[MOSFET] |
              GND               |               |     |
                                |              GND    |
                                |                     |
 .------------------------------'                     |"""
    
    #diagram += "\nMatching Network:\n"
    if matching_network_type == 'l':
        diagram += l_network_diagram()
    elif matching_network_type == 'pi':
        diagram += pi_network_diagram()
    elif matching_network_type == 't':
        diagram += t_network_diagram()
    
    #diagram += "\nLow Pass Filter:\n"
    diagram += lpf_diagram()
    
    return diagram

def calculate_matching_network(f, C1, network_type):
    Z_out = calculate_output_impedance(f, C1)
    if network_type == 'l':
        L_match, C_match = l_network(f, Z_out)
        return [('L_match', L_match), ('C_match', C_match)]
    elif network_type == 'pi':
        C1_match, L_match, C2_match = pi_network(f, Z_out)
        return [('C1_match', C1_match), ('L_match', L_match), ('C2_match', C2_match)]
    elif network_type == 't':
        L1_match, C_match, L2_match = t_network(f, Z_out)
        return [('L1_match', L1_match), ('C_match', C_match), ('L2_match', L2_match)]
    else:
        raise ValueError("Invalid network type. Choose 'L', 'Pi', or 'T'.")

def create_parser():
    parser = argparse.ArgumentParser(description='Class-E RF Power Amplifier Calculator')
    
    parser.add_argument('-p', '--power', type=float, required=True, help='Output power in watts')
    parser.add_argument('-v', '--voltage', type=float, required=True, help='Supply voltage')
    parser.add_argument('-b', '--bands', nargs='+', choices=AVAILABLE_BANDS, metavar='BANDLIST', required=True, help='Amateur radio band(s) (eg. 20m 40m)')
    parser.add_argument('-t', '--type', choices=['infinite', 'finite', 'inverse'], default='infinite', help='Topology type selection')
    parser.add_argument('-q', '--q-factor', type=float, help='Q factor (optional)')
    parser.add_argument('-m', '--mosfet', choices=AVAILABLE_MOSFETS, metavar='MOSFET', required=True, help='MOSFET')
    parser.add_argument('-M', '--matching', choices=['l', 'pi', 't'], default='pi', help='Matching network type')
    parser.add_argument('--list-bands', action='store_true', help='List available bands and exit')
    parser.add_argument('--list-mosfets', action='store_true', help='List available MOSFETs and exit')
    parser.add_argument('--l1', type=str, help='Specify L1 value (e.g., 10uh)')
    #parser.add_argument('--c1', type=str, help='Specify C1 value (e.g., 100pf)')
    #parser.add_argument('--c2', type=str, help='Specify C2 value (e.g., 50pf)')
    #parser.add_argument('--l2', type=str, help='Specify L2 value (e.g., 5uh)')
    parser.add_argument('--r', type=float, help='Specify load resistance (ohms)')
    parser.add_argument('--duty-cycle', type=float, default=0.5, help='Duty cycle (default: 0.5)')
    parser.add_argument('--efficiency', type=float, default=0.85, help='Efficiency (default: 0.85)')
    
    return parser

def parse_arguments():
    parser = create_parser()
    args = parser.parse_args()
    return args

def main():
    args = parse_arguments()

    matching_network_type = args.matching.lower() if args.matching else 'pi'

    frequency_bands = load_frequency_bands()
    mosfets = load_mosfets()

    if args.list_bands:
        list_available_bands(frequency_bands)
        return
    elif args.list_mosfets:
        list_available_mosfets(mosfets)
        return

    # Check for required arguments for main operation
    if not all([args.power, args.voltage, args.bands, args.mosfet]):
        parser.error("The following arguments are required: -p/--power, -v/--voltage, -b/--bands, -m/--mosfet")

    if args.mosfet not in mosfets:
        print(f"Error: MOSFET '{args.mosfet}' not found in mosfets.json")
        return

    mosfet_data = mosfets[args.mosfet]
    mosfet_info = f"{args.mosfet} (Vdss={mosfet_data['vdss_v']}V, Id={mosfet_data['id_a']}A, Rds_on={mosfet_data['rds_on_o']}Ω, Ciss={mosfet_data['ciss_pf']}pF, Coss={mosfet_data['coss_pf']}pF, Crss={mosfet_data['crss_pf']}pF, Vgs_th={mosfet_data['vgs_th_v']}V)"

    print("\nInput parameters:")
    print(f" Output Power = {format_power_value(args.power)}")
    print(f" Supply Voltage = {format_voltage_value(args.voltage)}")
    print(f" MOSFET = {mosfet_info}")
    print(f" Q Factor = {args.q_factor}")

    band_ids = args.bands #.split(',')

    generator = ClassETopologyGenerator()

    for band_id in band_ids:
        if band_id not in frequency_bands:
            print(f"Warning: Band '{band_id}' not found in frequency_bands.json. Skipping.")
            continue

        band_data = frequency_bands[band_id]
        center_freq, bandwidth = calculate_center_frequency_and_bandwidth(band_data)

        if args.q_factor is None:
            q_factor = calculate_auto_q(band_data)
        else:
            q_factor = args.q_factor

        args.l1 = parse_inductance(args.l1)

        if args.type == "infinite":
            topology = generator.class_e_topology_generate_infinite(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)
        elif args.type == "finite":
            topology = generator.class_e_topology_generate_finite(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)
        elif args.type == "inverse":
            topology = generator.class_e_topology_generate_inverse(args.power, args.voltage, center_freq, bandwidth, mosfet_data, q_factor, args.l1)

        operating_params = generator.calculate_operating_parameters(args.voltage, center_freq, q_factor, topology['R'])

        print(f"\n[{band_id}] @ {format_frequency_value(band_data['start'] * 1e6)}-{format_frequency_value(band_data['end'] * 1e6)} (c={format_frequency_value(center_freq)}, nbw={format_frequency_value(bandwidth)}, bw={format_frequency_value(operating_params['bandwidth'])}, q={format_number(q_factor)})")
        print(f" Power Amplifier components:")
        print(f"  Topology = {args.type}")
        if args.type == "infinite":
            if topology['L1_status'] == "user-specified":
                print(f"  L1 = {format_inductance_value(topology['L1'])} (user-specified)")
            else:
                print(f"  L1 ≥ {format_inductance_value(topology['L1'])} (calculated)")
        else:
            print(f"  L1 = {format_inductance_value(topology['L1'])} ({topology['L1_status']})")
        print(f"  L2 = {format_inductance_value(topology['L2'])}")
        print(f"  C1 = {format_capacitance_value(topology['C1'])}")
        print(f"  C2 = {format_capacitance_value(topology['C2'])}")
        print(f"  R = {format_resistance_value(topology['R'])} (before matching)")

        best_configs = find_best_configurations(topology['L2'], topology['C1'], topology['C2'], center_freq)

        # determine matching network
        matching_components = calculate_matching_network(center_freq, topology['C1'], matching_network_type)

        # determine lpf
        f_cutoff = 1.3 * center_freq # Set cutoff frequency 30% above operating frequency
        lpf_components = calculate_lpf(f_cutoff)

        print("\n  Top 3 recommended Power Amplifier component configurations:")
        for i, config in enumerate(best_configs, 1):
            L2, C1, C2, L2_type, L2_desc, C1_type, C1_desc, C2_type, C2_desc, error, srf_margin, component_count = config
            esr_mult = esr_multiplier(L2_type, 2 if L2_type != 'single' else 1)
            current_mult = current_multiplier(L2_type, 2 if L2_type != 'single' else 1)
            srf_ok, srf_status = check_srf_margin(srf_margin)
            print(f"\n   Configuration {i}: ({format_percentage(error)} error, estimated SRF margin {format_number(srf_margin)} ({srf_status}), {component_count} parts)")
            if not srf_ok:
                print("   (SRF Concern: Consider using a different inductor or parallel combination for L2)")
            print(f"     L2 = {format_inductance_value(L2)} ({L2_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")
            esr_mult = esr_multiplier(C1_type, 2 if C1_type != 'single' else 1)
            current_mult = current_multiplier(C1_type, 2 if C1_type != 'single' else 1)
            print(f"     C1 = {format_capacitance_value(C1)} ({C1_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")
            esr_mult = esr_multiplier(C2_type, 2 if C2_type != 'single' else 1)
            current_mult = current_multiplier(C2_type, 2 if C2_type != 'single' else 1)
            print(f"     C2 = {format_capacitance_value(C2)} ({C2_desc}) [ESR={esr_mult:.2f}x] [I={current_mult:.2f}x]")

        # Matching networks
        print("\n Matching Network Configurations:")
        matching_targets = {}
        for name, value in matching_components:
            if name.startswith('L'):
                matching_targets[name] = value * 1e6
            else:  # Capacitor
                matching_targets[name] = value * 1e12

        matching_configs = generate_combinations(matching_targets, {
            name: COMPONENTS['inductors_uh' if name.startswith('L') else 'capacitors_pf']
            for name, _ in matching_components
        })

        for i, config in enumerate(matching_configs[:3], 1):
            print(f"  Configuration {i}:")
            for j, (name, _) in enumerate(matching_components):
                print(f"  {name}: {format_configuration(config[j], name[0])}")
            print()


        # Low Pass Filter Configurations
        print("\n Low Pass Filter Configurations:")
        lpf_targets = {f" {component_type}{i+1}_lpf": value * (1e12 if component_type == 'C' else 1e6)
                   for i, (component_type, value) in enumerate(lpf_components)}
        lpf_configs = generate_combinations(lpf_targets, {
            f" {component_type}{i+1}_lpf": COMPONENTS['capacitors_pf' if component_type == 'C' else 'inductors_uh']
            for i, (component_type, _) in enumerate(lpf_components)
        })

        for i, config in enumerate(lpf_configs[:3], 1):
            print(f"  Configuration {i}:")
            for j, (component_type, _) in enumerate(lpf_components):
                name = f" {component_type}{j+1}_lpf"
                print(f"  {name}: {format_configuration(config[j], component_type)}")
            print()

        # Generate and print the topology diagram
        topology_diagram = generate_topology_diagram(matching_network_type)
        print(topology_diagram)

if __name__ == "__main__":
    main()
